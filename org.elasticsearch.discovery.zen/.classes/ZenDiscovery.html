


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html id="htmlId">
<head>
  <title>Coverage Report :: ZenDiscovery</title>
  <style type="text/css">
    @import "../../.css/coverage.css";
  </style>
</head>

<body>
<div class="header"></div>

<div class="content">
<div class="breadCrumbs">
    [ <a href="../../index.html">all classes</a> ]
    [ <a href="../index.html">org.elasticsearch.discovery.zen</a> ]
</div>

<h1>Coverage Summary for Class: ZenDiscovery (org.elasticsearch.discovery.zen)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">ZenDiscovery</td>
<td class="coverageStat">
  <span class="percent">
    9.3%
  </span>
  <span class="absValue">
    (4/ 43)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    5.1%
  </span>
  <span class="absValue">
    (23/ 448)
  </span>
</td>
</tr>
  <tr>
    <td class="name">ZenDiscovery$NodeFaultDetectionListener</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 20)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ZenDiscovery$RejoinClusterRequest</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ZenDiscovery$ZenNodeRemovalClusterStateTaskExecutor</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 11)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>total</strong></td>
<td class="coverageStat">
  <span class="percent">
    7.7%
  </span>
  <span class="absValue">
    (4/ 52)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    4.7%
  </span>
  <span class="absValue">
    (23/ 489)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<div class="sourceCode"><i>1</i>&nbsp;/*
<i>2</i>&nbsp; * Licensed to Elasticsearch under one or more contributor
<i>3</i>&nbsp; * license agreements. See the NOTICE file distributed with
<i>4</i>&nbsp; * this work for additional information regarding copyright
<i>5</i>&nbsp; * ownership. Elasticsearch licenses this file to you under
<i>6</i>&nbsp; * the Apache License, Version 2.0 (the &quot;License&quot;); you may
<i>7</i>&nbsp; * not use this file except in compliance with the License.
<i>8</i>&nbsp; * You may obtain a copy of the License at
<i>9</i>&nbsp; *
<i>10</i>&nbsp; *    http://www.apache.org/licenses/LICENSE-2.0
<i>11</i>&nbsp; *
<i>12</i>&nbsp; * Unless required by applicable law or agreed to in writing,
<i>13</i>&nbsp; * software distributed under the License is distributed on an
<i>14</i>&nbsp; * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
<i>15</i>&nbsp; * KIND, either express or implied.  See the License for the
<i>16</i>&nbsp; * specific language governing permissions and limitations
<i>17</i>&nbsp; * under the License.
<i>18</i>&nbsp; */
<i>19</i>&nbsp;
<i>20</i>&nbsp;package org.elasticsearch.discovery.zen;
<i>21</i>&nbsp;
<i>22</i>&nbsp;import org.apache.logging.log4j.LogManager;
<i>23</i>&nbsp;import org.apache.logging.log4j.Logger;
<i>24</i>&nbsp;import org.apache.logging.log4j.message.ParameterizedMessage;
<i>25</i>&nbsp;import org.elasticsearch.ElasticsearchException;
<i>26</i>&nbsp;import org.elasticsearch.ExceptionsHelper;
<i>27</i>&nbsp;import org.elasticsearch.action.ActionListener;
<i>28</i>&nbsp;import org.elasticsearch.cluster.ClusterChangedEvent;
<i>29</i>&nbsp;import org.elasticsearch.cluster.ClusterName;
<i>30</i>&nbsp;import org.elasticsearch.cluster.ClusterState;
<i>31</i>&nbsp;import org.elasticsearch.cluster.ClusterStateTaskConfig;
<i>32</i>&nbsp;import org.elasticsearch.cluster.NotMasterException;
<i>33</i>&nbsp;import org.elasticsearch.cluster.block.ClusterBlocks;
<i>34</i>&nbsp;import org.elasticsearch.cluster.coordination.FailedToCommitClusterStateException;
<i>35</i>&nbsp;import org.elasticsearch.cluster.coordination.JoinTaskExecutor;
<i>36</i>&nbsp;import org.elasticsearch.cluster.coordination.NoMasterBlockService;
<i>37</i>&nbsp;import org.elasticsearch.cluster.coordination.NodeRemovalClusterStateTaskExecutor;
<i>38</i>&nbsp;import org.elasticsearch.cluster.node.DiscoveryNode;
<i>39</i>&nbsp;import org.elasticsearch.cluster.node.DiscoveryNodes;
<i>40</i>&nbsp;import org.elasticsearch.cluster.routing.RerouteService;
<i>41</i>&nbsp;import org.elasticsearch.cluster.routing.allocation.AllocationService;
<i>42</i>&nbsp;import org.elasticsearch.cluster.service.ClusterApplier;
<i>43</i>&nbsp;import org.elasticsearch.cluster.service.ClusterApplier.ClusterApplyListener;
<i>44</i>&nbsp;import org.elasticsearch.cluster.service.MasterService;
<i>45</i>&nbsp;import org.elasticsearch.common.Priority;
<i>46</i>&nbsp;import org.elasticsearch.common.component.AbstractLifecycleComponent;
<i>47</i>&nbsp;import org.elasticsearch.common.component.Lifecycle;
<i>48</i>&nbsp;import org.elasticsearch.common.io.stream.NamedWriteableRegistry;
<i>49</i>&nbsp;import org.elasticsearch.common.io.stream.StreamInput;
<i>50</i>&nbsp;import org.elasticsearch.common.io.stream.StreamOutput;
<i>51</i>&nbsp;import org.elasticsearch.common.lease.Releasables;
<i>52</i>&nbsp;import org.elasticsearch.common.logging.LoggerMessageFormat;
<i>53</i>&nbsp;import org.elasticsearch.common.settings.ClusterSettings;
<i>54</i>&nbsp;import org.elasticsearch.common.settings.Setting;
<i>55</i>&nbsp;import org.elasticsearch.common.settings.Setting.Property;
<i>56</i>&nbsp;import org.elasticsearch.common.settings.Settings;
<i>57</i>&nbsp;import org.elasticsearch.common.unit.TimeValue;
<i>58</i>&nbsp;import org.elasticsearch.core.internal.io.IOUtils;
<i>59</i>&nbsp;import org.elasticsearch.discovery.Discovery;
<i>60</i>&nbsp;import org.elasticsearch.discovery.DiscoverySettings;
<i>61</i>&nbsp;import org.elasticsearch.discovery.DiscoveryStats;
<i>62</i>&nbsp;import org.elasticsearch.discovery.SeedHostsProvider;
<i>63</i>&nbsp;import org.elasticsearch.discovery.zen.PublishClusterStateAction.IncomingClusterStateListener;
<i>64</i>&nbsp;import org.elasticsearch.tasks.Task;
<i>65</i>&nbsp;import org.elasticsearch.threadpool.ThreadPool;
<i>66</i>&nbsp;import org.elasticsearch.transport.EmptyTransportResponseHandler;
<i>67</i>&nbsp;import org.elasticsearch.transport.TransportChannel;
<i>68</i>&nbsp;import org.elasticsearch.transport.TransportException;
<i>69</i>&nbsp;import org.elasticsearch.transport.TransportRequest;
<i>70</i>&nbsp;import org.elasticsearch.transport.TransportRequestHandler;
<i>71</i>&nbsp;import org.elasticsearch.transport.TransportResponse;
<i>72</i>&nbsp;import org.elasticsearch.transport.TransportService;
<i>73</i>&nbsp;
<i>74</i>&nbsp;import java.io.IOException;
<i>75</i>&nbsp;import java.util.ArrayList;
<i>76</i>&nbsp;import java.util.Collection;
<i>77</i>&nbsp;import java.util.List;
<i>78</i>&nbsp;import java.util.Locale;
<i>79</i>&nbsp;import java.util.Set;
<i>80</i>&nbsp;import java.util.concurrent.CompletableFuture;
<i>81</i>&nbsp;import java.util.concurrent.ExecutionException;
<i>82</i>&nbsp;import java.util.concurrent.atomic.AtomicBoolean;
<i>83</i>&nbsp;import java.util.concurrent.atomic.AtomicInteger;
<i>84</i>&nbsp;import java.util.concurrent.atomic.AtomicReference;
<i>85</i>&nbsp;import java.util.function.BiConsumer;
<i>86</i>&nbsp;import java.util.function.Consumer;
<i>87</i>&nbsp;import java.util.stream.Collectors;
<i>88</i>&nbsp;
<i>89</i>&nbsp;import static org.elasticsearch.common.unit.TimeValue.timeValueSeconds;
<i>90</i>&nbsp;import static org.elasticsearch.gateway.GatewayService.STATE_NOT_RECOVERED_BLOCK;
<i>91</i>&nbsp;
<b class="fc"><i>92</i>&nbsp;public class ZenDiscovery extends AbstractLifecycleComponent implements Discovery, PingContextProvider, IncomingClusterStateListener {</b>
<b class="fc"><i>93</i>&nbsp;    private static final Logger logger = LogManager.getLogger(ZenDiscovery.class);</b>
<i>94</i>&nbsp;
<b class="fc"><i>95</i>&nbsp;    public static final Setting&lt;TimeValue&gt; PING_TIMEOUT_SETTING =</b>
<b class="fc"><i>96</i>&nbsp;        Setting.positiveTimeSetting(&quot;discovery.zen.ping_timeout&quot;, timeValueSeconds(3), Property.NodeScope);</b>
<b class="fc"><i>97</i>&nbsp;    public static final Setting&lt;TimeValue&gt; JOIN_TIMEOUT_SETTING =</b>
<b class="fc"><i>98</i>&nbsp;        Setting.timeSetting(&quot;discovery.zen.join_timeout&quot;,</b>
<b class="fc"><i>99</i>&nbsp;            settings -&gt; TimeValue.timeValueMillis(PING_TIMEOUT_SETTING.get(settings).millis() * 20),</b>
<b class="fc"><i>100</i>&nbsp;            TimeValue.timeValueMillis(0), Property.NodeScope, Property.Deprecated);</b>
<b class="fc"><i>101</i>&nbsp;    public static final Setting&lt;Integer&gt; JOIN_RETRY_ATTEMPTS_SETTING =</b>
<b class="fc"><i>102</i>&nbsp;        Setting.intSetting(&quot;discovery.zen.join_retry_attempts&quot;, 3, 1, Property.NodeScope, Property.Deprecated);</b>
<b class="fc"><i>103</i>&nbsp;    public static final Setting&lt;TimeValue&gt; JOIN_RETRY_DELAY_SETTING =</b>
<b class="fc"><i>104</i>&nbsp;        Setting.positiveTimeSetting(&quot;discovery.zen.join_retry_delay&quot;, TimeValue.timeValueMillis(100),</b>
<i>105</i>&nbsp;            Property.NodeScope, Property.Deprecated);
<b class="fc"><i>106</i>&nbsp;    public static final Setting&lt;Integer&gt; MAX_PINGS_FROM_ANOTHER_MASTER_SETTING =</b>
<b class="fc"><i>107</i>&nbsp;        Setting.intSetting(&quot;discovery.zen.max_pings_from_another_master&quot;, 3, 1, Property.NodeScope, Property.Deprecated);</b>
<b class="fc"><i>108</i>&nbsp;    public static final Setting&lt;Boolean&gt; SEND_LEAVE_REQUEST_SETTING =</b>
<b class="fc"><i>109</i>&nbsp;        Setting.boolSetting(&quot;discovery.zen.send_leave_request&quot;, true, Property.NodeScope, Property.Deprecated);</b>
<b class="fc"><i>110</i>&nbsp;    public static final Setting&lt;TimeValue&gt; MASTER_ELECTION_WAIT_FOR_JOINS_TIMEOUT_SETTING =</b>
<b class="fc"><i>111</i>&nbsp;        Setting.timeSetting(&quot;discovery.zen.master_election.wait_for_joins_timeout&quot;,</b>
<b class="fc"><i>112</i>&nbsp;            settings -&gt; TimeValue.timeValueMillis(JOIN_TIMEOUT_SETTING.get(settings).millis() / 2), TimeValue.timeValueMillis(0),</b>
<i>113</i>&nbsp;            Property.NodeScope, Property.Deprecated);
<b class="fc"><i>114</i>&nbsp;    public static final Setting&lt;Boolean&gt; MASTER_ELECTION_IGNORE_NON_MASTER_PINGS_SETTING =</b>
<b class="fc"><i>115</i>&nbsp;            Setting.boolSetting(&quot;discovery.zen.master_election.ignore_non_master_pings&quot;, false, Property.NodeScope, Property.Deprecated);</b>
<b class="fc"><i>116</i>&nbsp;    public static final Setting&lt;Integer&gt; MAX_PENDING_CLUSTER_STATES_SETTING =</b>
<b class="fc"><i>117</i>&nbsp;        Setting.intSetting(&quot;discovery.zen.publish.max_pending_cluster_states&quot;, 25, 1, Property.NodeScope, Property.Deprecated);</b>
<i>118</i>&nbsp;
<i>119</i>&nbsp;    public static final String DISCOVERY_REJOIN_ACTION_NAME = &quot;internal:discovery/zen/rejoin&quot;;
<i>120</i>&nbsp;
<i>121</i>&nbsp;    private final TransportService transportService;
<i>122</i>&nbsp;    private final MasterService masterService;
<i>123</i>&nbsp;    private final DiscoverySettings discoverySettings;
<i>124</i>&nbsp;    private final NoMasterBlockService noMasterBlockService;
<i>125</i>&nbsp;    protected final ZenPing zenPing; // protected to allow tests access
<i>126</i>&nbsp;    private final MasterFaultDetection masterFD;
<i>127</i>&nbsp;    private final NodesFaultDetection nodesFD;
<i>128</i>&nbsp;    private final PublishClusterStateAction publishClusterState;
<i>129</i>&nbsp;    private final MembershipAction membership;
<i>130</i>&nbsp;    private final ClusterName clusterName;
<i>131</i>&nbsp;    private final ThreadPool threadPool;
<i>132</i>&nbsp;
<i>133</i>&nbsp;    private final TimeValue pingTimeout;
<i>134</i>&nbsp;    private final TimeValue joinTimeout;
<i>135</i>&nbsp;
<i>136</i>&nbsp;    /** how many retry attempts to perform if join request failed with an retryable error */
<i>137</i>&nbsp;    private final int joinRetryAttempts;
<i>138</i>&nbsp;    /** how long to wait before performing another join attempt after a join request failed with an retryable error */
<i>139</i>&nbsp;    private final TimeValue joinRetryDelay;
<i>140</i>&nbsp;
<i>141</i>&nbsp;    /** how many pings from *another* master to tolerate before forcing a rejoin on other or local master */
<i>142</i>&nbsp;    private final int maxPingsFromAnotherMaster;
<i>143</i>&nbsp;
<i>144</i>&nbsp;    // a flag that should be used only for testing
<i>145</i>&nbsp;    private final boolean sendLeaveRequest;
<i>146</i>&nbsp;
<i>147</i>&nbsp;    private final ElectMasterService electMaster;
<i>148</i>&nbsp;
<i>149</i>&nbsp;    private final boolean masterElectionIgnoreNonMasters;
<i>150</i>&nbsp;    private final TimeValue masterElectionWaitForJoinsTimeout;
<i>151</i>&nbsp;
<i>152</i>&nbsp;    private final JoinThreadControl joinThreadControl;
<i>153</i>&nbsp;
<i>154</i>&nbsp;    private final PendingClusterStatesQueue pendingStatesQueue;
<i>155</i>&nbsp;
<i>156</i>&nbsp;    private final NodeJoinController nodeJoinController;
<i>157</i>&nbsp;    private final NodeRemovalClusterStateTaskExecutor nodeRemovalExecutor;
<i>158</i>&nbsp;    private final ClusterApplier clusterApplier;
<i>159</i>&nbsp;    private final AtomicReference&lt;ClusterState&gt; committedState; // last committed cluster state
<b class="nc"><i>160</i>&nbsp;    private final Object stateMutex = new Object();</b>
<i>161</i>&nbsp;    private final Collection&lt;BiConsumer&lt;DiscoveryNode, ClusterState&gt;&gt; onJoinValidators;
<i>162</i>&nbsp;
<i>163</i>&nbsp;    public ZenDiscovery(Settings settings, ThreadPool threadPool, TransportService transportService,
<i>164</i>&nbsp;                        NamedWriteableRegistry namedWriteableRegistry, MasterService masterService, ClusterApplier clusterApplier,
<i>165</i>&nbsp;                        ClusterSettings clusterSettings, SeedHostsProvider hostsProvider, AllocationService allocationService,
<b class="nc"><i>166</i>&nbsp;                        Collection&lt;BiConsumer&lt;DiscoveryNode, ClusterState&gt;&gt; onJoinValidators, RerouteService rerouteService) {</b>
<b class="nc"><i>167</i>&nbsp;        this.onJoinValidators = JoinTaskExecutor.addBuiltInJoinValidators(onJoinValidators);</b>
<b class="nc"><i>168</i>&nbsp;        this.masterService = masterService;</b>
<b class="nc"><i>169</i>&nbsp;        this.clusterApplier = clusterApplier;</b>
<b class="nc"><i>170</i>&nbsp;        this.transportService = transportService;</b>
<b class="nc"><i>171</i>&nbsp;        this.discoverySettings = new DiscoverySettings(settings, clusterSettings);</b>
<b class="nc"><i>172</i>&nbsp;        this.noMasterBlockService = new NoMasterBlockService(settings, clusterSettings);</b>
<b class="nc"><i>173</i>&nbsp;        this.zenPing = newZenPing(settings, threadPool, transportService, hostsProvider);</b>
<b class="nc"><i>174</i>&nbsp;        this.electMaster = new ElectMasterService(settings);</b>
<b class="nc"><i>175</i>&nbsp;        this.pingTimeout = PING_TIMEOUT_SETTING.get(settings);</b>
<b class="nc"><i>176</i>&nbsp;        this.joinTimeout = JOIN_TIMEOUT_SETTING.get(settings);</b>
<b class="nc"><i>177</i>&nbsp;        this.joinRetryAttempts = JOIN_RETRY_ATTEMPTS_SETTING.get(settings);</b>
<b class="nc"><i>178</i>&nbsp;        this.joinRetryDelay = JOIN_RETRY_DELAY_SETTING.get(settings);</b>
<b class="nc"><i>179</i>&nbsp;        this.maxPingsFromAnotherMaster = MAX_PINGS_FROM_ANOTHER_MASTER_SETTING.get(settings);</b>
<b class="nc"><i>180</i>&nbsp;        this.sendLeaveRequest = SEND_LEAVE_REQUEST_SETTING.get(settings);</b>
<b class="nc"><i>181</i>&nbsp;        this.threadPool = threadPool;</b>
<b class="nc"><i>182</i>&nbsp;        this.clusterName = ClusterName.CLUSTER_NAME_SETTING.get(settings);</b>
<b class="nc"><i>183</i>&nbsp;        this.committedState = new AtomicReference&lt;&gt;();</b>
<i>184</i>&nbsp;
<b class="nc"><i>185</i>&nbsp;        this.masterElectionIgnoreNonMasters = MASTER_ELECTION_IGNORE_NON_MASTER_PINGS_SETTING.get(settings);</b>
<b class="nc"><i>186</i>&nbsp;        this.masterElectionWaitForJoinsTimeout = MASTER_ELECTION_WAIT_FOR_JOINS_TIMEOUT_SETTING.get(settings);</b>
<i>187</i>&nbsp;
<b class="nc"><i>188</i>&nbsp;        logger.debug(&quot;using ping_timeout [{}], join.timeout [{}], master_election.ignore_non_master [{}]&quot;,</b>
<b class="nc"><i>189</i>&nbsp;                this.pingTimeout, joinTimeout, masterElectionIgnoreNonMasters);</b>
<i>190</i>&nbsp;
<b class="nc"><i>191</i>&nbsp;        clusterSettings.addSettingsUpdateConsumer(ElectMasterService.DISCOVERY_ZEN_MINIMUM_MASTER_NODES_SETTING,</b>
<i>192</i>&nbsp;            this::handleMinimumMasterNodesChanged, (value) -&gt; {
<b class="nc"><i>193</i>&nbsp;                final ClusterState clusterState = this.clusterState();</b>
<b class="nc"><i>194</i>&nbsp;                int masterNodes = clusterState.nodes().getMasterNodes().size();</b>
<i>195</i>&nbsp;                // the purpose of this validation is to make sure that the master doesn&#39;t step down
<i>196</i>&nbsp;                // due to a change in master nodes, which also means that there is no way to revert
<i>197</i>&nbsp;                // an accidental change. Since we validate using the current cluster state (and
<i>198</i>&nbsp;                // not the one from which the settings come from) we have to be careful and only
<i>199</i>&nbsp;                // validate if the local node is already a master. Doing so all the time causes
<i>200</i>&nbsp;                // subtle issues. For example, a node that joins a cluster has no nodes in its
<i>201</i>&nbsp;                // current cluster state. When it receives a cluster state from the master with
<i>202</i>&nbsp;                // a dynamic minimum master nodes setting int it, we must make sure we don&#39;t reject
<i>203</i>&nbsp;                // it.
<i>204</i>&nbsp;
<b class="nc"><i>205</i>&nbsp;                if (clusterState.nodes().isLocalNodeElectedMaster() &amp;&amp; value &gt; masterNodes) {</b>
<b class="nc"><i>206</i>&nbsp;                    throw new IllegalArgumentException(&quot;cannot set &quot;</b>
<b class="nc"><i>207</i>&nbsp;                        + ElectMasterService.DISCOVERY_ZEN_MINIMUM_MASTER_NODES_SETTING.getKey() + &quot; to more than the current&quot; +</b>
<i>208</i>&nbsp;                        &quot; master nodes count [&quot; + masterNodes + &quot;]&quot;);
<i>209</i>&nbsp;                }
<b class="nc"><i>210</i>&nbsp;        });</b>
<i>211</i>&nbsp;
<b class="nc"><i>212</i>&nbsp;        this.masterFD = new MasterFaultDetection(settings, threadPool, transportService, this::clusterState, masterService, clusterName);</b>
<b class="nc"><i>213</i>&nbsp;        this.masterFD.addListener(new MasterNodeFailureListener());</b>
<b class="nc"><i>214</i>&nbsp;        this.nodesFD = new NodesFaultDetection(settings, threadPool, transportService, this::clusterState, clusterName);</b>
<b class="nc"><i>215</i>&nbsp;        this.nodesFD.addListener(new NodeFaultDetectionListener());</b>
<b class="nc"><i>216</i>&nbsp;        this.pendingStatesQueue = new PendingClusterStatesQueue(logger, MAX_PENDING_CLUSTER_STATES_SETTING.get(settings));</b>
<i>217</i>&nbsp;
<b class="nc"><i>218</i>&nbsp;        this.publishClusterState =</b>
<i>219</i>&nbsp;                new PublishClusterStateAction(
<i>220</i>&nbsp;                        transportService,
<i>221</i>&nbsp;                        namedWriteableRegistry,
<i>222</i>&nbsp;                        this,
<i>223</i>&nbsp;                        discoverySettings);
<b class="nc"><i>224</i>&nbsp;        this.membership = new MembershipAction(transportService, new MembershipListener(), onJoinValidators);</b>
<b class="nc"><i>225</i>&nbsp;        this.joinThreadControl = new JoinThreadControl();</b>
<i>226</i>&nbsp;
<b class="nc"><i>227</i>&nbsp;        this.nodeJoinController = new NodeJoinController(settings, masterService, allocationService, electMaster, rerouteService);</b>
<b class="nc"><i>228</i>&nbsp;        this.nodeRemovalExecutor = new ZenNodeRemovalClusterStateTaskExecutor(allocationService, electMaster, this::submitRejoin, logger);</b>
<i>229</i>&nbsp;
<b class="nc"><i>230</i>&nbsp;        masterService.setClusterStateSupplier(this::clusterState);</b>
<i>231</i>&nbsp;
<b class="nc"><i>232</i>&nbsp;        transportService.registerRequestHandler(</b>
<i>233</i>&nbsp;            DISCOVERY_REJOIN_ACTION_NAME, ThreadPool.Names.SAME, RejoinClusterRequest::new, new RejoinClusterRequestHandler());
<b class="nc"><i>234</i>&nbsp;    }</b>
<i>235</i>&nbsp;
<i>236</i>&nbsp;    // protected to allow overriding in tests
<i>237</i>&nbsp;    protected ZenPing newZenPing(Settings settings, ThreadPool threadPool, TransportService transportService,
<i>238</i>&nbsp;                                 SeedHostsProvider hostsProvider) {
<b class="nc"><i>239</i>&nbsp;        return new UnicastZenPing(settings, threadPool, transportService, hostsProvider, this);</b>
<i>240</i>&nbsp;    }
<i>241</i>&nbsp;
<i>242</i>&nbsp;    @Override
<i>243</i>&nbsp;    protected void doStart() {
<b class="nc"><i>244</i>&nbsp;        DiscoveryNode localNode = transportService.getLocalNode();</b>
<b class="nc"><i>245</i>&nbsp;        assert localNode != null;</b>
<b class="nc"><i>246</i>&nbsp;        synchronized (stateMutex) {</b>
<i>247</i>&nbsp;            // set initial state
<b class="nc"><i>248</i>&nbsp;            assert committedState.get() == null;</b>
<b class="nc"><i>249</i>&nbsp;            assert localNode != null;</b>
<b class="nc"><i>250</i>&nbsp;            ClusterState.Builder builder = ClusterState.builder(clusterName);</b>
<b class="nc"><i>251</i>&nbsp;            ClusterState initialState = builder</b>
<b class="nc"><i>252</i>&nbsp;                .blocks(ClusterBlocks.builder()</b>
<b class="nc"><i>253</i>&nbsp;                    .addGlobalBlock(STATE_NOT_RECOVERED_BLOCK)</b>
<b class="nc"><i>254</i>&nbsp;                    .addGlobalBlock(noMasterBlockService.getNoMasterBlock()))</b>
<b class="nc"><i>255</i>&nbsp;                .nodes(DiscoveryNodes.builder().add(localNode).localNodeId(localNode.getId()))</b>
<b class="nc"><i>256</i>&nbsp;                .build();</b>
<b class="nc"><i>257</i>&nbsp;            committedState.set(initialState);</b>
<b class="nc"><i>258</i>&nbsp;            clusterApplier.setInitialState(initialState);</b>
<b class="nc"><i>259</i>&nbsp;            nodesFD.setLocalNode(localNode);</b>
<b class="nc"><i>260</i>&nbsp;            joinThreadControl.start();</b>
<b class="nc"><i>261</i>&nbsp;        }</b>
<b class="nc"><i>262</i>&nbsp;        zenPing.start();</b>
<b class="nc"><i>263</i>&nbsp;    }</b>
<i>264</i>&nbsp;
<i>265</i>&nbsp;    @Override
<i>266</i>&nbsp;    public void startInitialJoin() {
<i>267</i>&nbsp;        // start the join thread from a cluster state update. See {@link JoinThreadControl} for details.
<b class="nc"><i>268</i>&nbsp;        synchronized (stateMutex) {</b>
<i>269</i>&nbsp;            // do the join on a different thread, the caller of this method waits for 30s anyhow till it is discovered
<b class="nc"><i>270</i>&nbsp;            joinThreadControl.startNewThreadIfNotRunning();</b>
<b class="nc"><i>271</i>&nbsp;        }</b>
<b class="nc"><i>272</i>&nbsp;    }</b>
<i>273</i>&nbsp;
<i>274</i>&nbsp;    @Override
<i>275</i>&nbsp;    protected void doStop() {
<b class="nc"><i>276</i>&nbsp;        joinThreadControl.stop();</b>
<b class="nc"><i>277</i>&nbsp;        masterFD.stop(&quot;zen disco stop&quot;);</b>
<b class="nc"><i>278</i>&nbsp;        nodesFD.stop();</b>
<b class="nc"><i>279</i>&nbsp;        Releasables.close(zenPing); // stop any ongoing pinging</b>
<b class="nc"><i>280</i>&nbsp;        DiscoveryNodes nodes = clusterState().nodes();</b>
<b class="nc"><i>281</i>&nbsp;        if (sendLeaveRequest) {</b>
<b class="nc"><i>282</i>&nbsp;            if (nodes.getMasterNode() == null) {</b>
<i>283</i>&nbsp;                // if we don&#39;t know who the master is, nothing to do here
<b class="nc"><i>284</i>&nbsp;            } else if (!nodes.isLocalNodeElectedMaster()) {</b>
<i>285</i>&nbsp;                try {
<b class="nc"><i>286</i>&nbsp;                    membership.sendLeaveRequestBlocking(nodes.getMasterNode(), nodes.getLocalNode(), TimeValue.timeValueSeconds(1));</b>
<b class="nc"><i>287</i>&nbsp;                } catch (Exception e) {</b>
<b class="nc"><i>288</i>&nbsp;                    logger.debug(() -&gt; new ParameterizedMessage(&quot;failed to send leave request to master [{}]&quot;, nodes.getMasterNode()), e);</b>
<b class="nc"><i>289</i>&nbsp;                }</b>
<i>290</i>&nbsp;            } else {
<i>291</i>&nbsp;                // we&#39;re master -&gt; let other potential master we left and start a master election now rather then wait for masterFD
<b class="nc"><i>292</i>&nbsp;                DiscoveryNode[] possibleMasters = electMaster.nextPossibleMasters(nodes.getNodes().values(), 5);</b>
<b class="nc"><i>293</i>&nbsp;                for (DiscoveryNode possibleMaster : possibleMasters) {</b>
<b class="nc"><i>294</i>&nbsp;                    if (nodes.getLocalNode().equals(possibleMaster)) {</b>
<b class="nc"><i>295</i>&nbsp;                        continue;</b>
<i>296</i>&nbsp;                    }
<i>297</i>&nbsp;                    try {
<b class="nc"><i>298</i>&nbsp;                        membership.sendLeaveRequest(nodes.getLocalNode(), possibleMaster);</b>
<b class="nc"><i>299</i>&nbsp;                    } catch (Exception e) {</b>
<b class="nc"><i>300</i>&nbsp;                        logger.debug(() -&gt; new ParameterizedMessage(&quot;failed to send leave request from master [{}] to possible master [{}]&quot;,</b>
<b class="nc"><i>301</i>&nbsp;                            nodes.getMasterNode(), possibleMaster), e);</b>
<b class="nc"><i>302</i>&nbsp;                    }</b>
<i>303</i>&nbsp;                }
<i>304</i>&nbsp;            }
<i>305</i>&nbsp;        }
<b class="nc"><i>306</i>&nbsp;    }</b>
<i>307</i>&nbsp;
<i>308</i>&nbsp;    @Override
<i>309</i>&nbsp;    protected void doClose() throws IOException {
<b class="nc"><i>310</i>&nbsp;        IOUtils.close(masterFD, nodesFD);</b>
<b class="nc"><i>311</i>&nbsp;    }</b>
<i>312</i>&nbsp;
<i>313</i>&nbsp;    @Override
<i>314</i>&nbsp;    public ClusterState clusterState() {
<b class="nc"><i>315</i>&nbsp;        ClusterState clusterState = committedState.get();</b>
<b class="nc"><i>316</i>&nbsp;        assert clusterState != null : &quot;accessing cluster state before it is set&quot;;</b>
<b class="nc"><i>317</i>&nbsp;        return clusterState;</b>
<i>318</i>&nbsp;    }
<i>319</i>&nbsp;
<i>320</i>&nbsp;    @Override
<i>321</i>&nbsp;    public void publish(ClusterChangedEvent clusterChangedEvent, ActionListener&lt;Void&gt; publishListener, AckListener ackListener) {
<b class="nc"><i>322</i>&nbsp;        ClusterState newState = clusterChangedEvent.state();</b>
<b class="nc"><i>323</i>&nbsp;        assert newState.getNodes().isLocalNodeElectedMaster() : &quot;Shouldn&#39;t publish state when not master &quot; + clusterChangedEvent.source();</b>
<i>324</i>&nbsp;
<i>325</i>&nbsp;        try {
<i>326</i>&nbsp;
<i>327</i>&nbsp;            // state got changed locally (maybe because another master published to us)
<b class="nc"><i>328</i>&nbsp;            if (clusterChangedEvent.previousState() != this.committedState.get()) {</b>
<b class="nc"><i>329</i>&nbsp;                throw new FailedToCommitClusterStateException(&quot;state was mutated while calculating new CS update&quot;);</b>
<i>330</i>&nbsp;            }
<i>331</i>&nbsp;
<b class="nc"><i>332</i>&nbsp;            pendingStatesQueue.addPending(newState);</b>
<i>333</i>&nbsp;
<b class="nc"><i>334</i>&nbsp;            publishClusterState.publish(clusterChangedEvent, electMaster.minimumMasterNodes(), ackListener);</b>
<b class="nc"><i>335</i>&nbsp;        } catch (FailedToCommitClusterStateException t) {</b>
<i>336</i>&nbsp;            // cluster service logs a WARN message
<b class="nc"><i>337</i>&nbsp;            logger.debug(&quot;failed to publish cluster state version [{}] (not enough nodes acknowledged, min master nodes [{}])&quot;,</b>
<b class="nc"><i>338</i>&nbsp;                newState.version(), electMaster.minimumMasterNodes());</b>
<i>339</i>&nbsp;
<b class="nc"><i>340</i>&nbsp;            synchronized (stateMutex) {</b>
<b class="nc"><i>341</i>&nbsp;                pendingStatesQueue.failAllStatesAndClear(</b>
<i>342</i>&nbsp;                    new ElasticsearchException(&quot;failed to publish cluster state&quot;));
<i>343</i>&nbsp;
<b class="nc"><i>344</i>&nbsp;                rejoin(&quot;zen-disco-failed-to-publish&quot;);</b>
<b class="nc"><i>345</i>&nbsp;            }</b>
<i>346</i>&nbsp;
<b class="nc"><i>347</i>&nbsp;            publishListener.onFailure(t);</b>
<b class="nc"><i>348</i>&nbsp;            return;</b>
<b class="nc"><i>349</i>&nbsp;        }</b>
<i>350</i>&nbsp;
<b class="nc"><i>351</i>&nbsp;        final DiscoveryNode localNode = newState.getNodes().getLocalNode();</b>
<b class="nc"><i>352</i>&nbsp;        final AtomicBoolean processedOrFailed = new AtomicBoolean();</b>
<b class="nc"><i>353</i>&nbsp;        pendingStatesQueue.markAsCommitted(newState.stateUUID(),</b>
<i>354</i>&nbsp;            new PendingClusterStatesQueue.StateProcessedListener() {
<i>355</i>&nbsp;                @Override
<i>356</i>&nbsp;                public void onNewClusterStateProcessed() {
<i>357</i>&nbsp;                    processedOrFailed.set(true);
<i>358</i>&nbsp;                    publishListener.onResponse(null);
<i>359</i>&nbsp;                    ackListener.onNodeAck(localNode, null);
<i>360</i>&nbsp;                }
<i>361</i>&nbsp;
<i>362</i>&nbsp;                @Override
<i>363</i>&nbsp;                public void onNewClusterStateFailed(Exception e) {
<i>364</i>&nbsp;                    processedOrFailed.set(true);
<i>365</i>&nbsp;                    publishListener.onFailure(e);
<i>366</i>&nbsp;                    ackListener.onNodeAck(localNode, e);
<i>367</i>&nbsp;                    logger.warn(() -&gt; new ParameterizedMessage(
<i>368</i>&nbsp;                            &quot;failed while applying cluster state locally [{}]&quot;, clusterChangedEvent.source()), e);
<i>369</i>&nbsp;                }
<i>370</i>&nbsp;            });
<i>371</i>&nbsp;
<b class="nc"><i>372</i>&nbsp;        synchronized (stateMutex) {</b>
<b class="nc"><i>373</i>&nbsp;            if (clusterChangedEvent.previousState() != this.committedState.get()) {</b>
<b class="nc"><i>374</i>&nbsp;                publishListener.onFailure(</b>
<i>375</i>&nbsp;                        new FailedToCommitClusterStateException(&quot;local state was mutated while CS update was published to other nodes&quot;)
<i>376</i>&nbsp;                );
<b class="nc"><i>377</i>&nbsp;                return;</b>
<i>378</i>&nbsp;            }
<i>379</i>&nbsp;
<b class="nc"><i>380</i>&nbsp;            boolean sentToApplier = processNextCommittedClusterState(&quot;master &quot; + newState.nodes().getMasterNode() +</b>
<b class="nc"><i>381</i>&nbsp;                &quot; committed version [&quot; + newState.version() + &quot;] source [&quot; + clusterChangedEvent.source() + &quot;]&quot;);</b>
<b class="nc"><i>382</i>&nbsp;            if (sentToApplier == false &amp;&amp; processedOrFailed.get() == false) {</b>
<b class="nc"><i>383</i>&nbsp;                assert false : &quot;cluster state published locally neither processed nor failed: &quot; + newState;</b>
<b class="nc"><i>384</i>&nbsp;                logger.warn(&quot;cluster state with version [{}] that is published locally has neither been processed nor failed&quot;,</b>
<b class="nc"><i>385</i>&nbsp;                    newState.version());</b>
<b class="nc"><i>386</i>&nbsp;                publishListener.onFailure(new FailedToCommitClusterStateException(&quot;cluster state that is published locally has neither &quot; +</b>
<i>387</i>&nbsp;                        &quot;been processed nor failed&quot;));
<i>388</i>&nbsp;            }
<b class="nc"><i>389</i>&nbsp;        }</b>
<b class="nc"><i>390</i>&nbsp;    }</b>
<i>391</i>&nbsp;
<i>392</i>&nbsp;    /**
<i>393</i>&nbsp;     * Gets the current set of nodes involved in the node fault detection.
<i>394</i>&nbsp;     * NB: for testing purposes
<i>395</i>&nbsp;     */
<i>396</i>&nbsp;    Set&lt;DiscoveryNode&gt; getFaultDetectionNodes() {
<b class="nc"><i>397</i>&nbsp;        return nodesFD.getNodes();</b>
<i>398</i>&nbsp;    }
<i>399</i>&nbsp;
<i>400</i>&nbsp;    @Override
<i>401</i>&nbsp;    public DiscoveryStats stats() {
<b class="nc"><i>402</i>&nbsp;        return new DiscoveryStats(pendingStatesQueue.stats(), publishClusterState.stats());</b>
<i>403</i>&nbsp;    }
<i>404</i>&nbsp;
<i>405</i>&nbsp;    public DiscoverySettings getDiscoverySettings() {
<b class="nc"><i>406</i>&nbsp;        return discoverySettings;</b>
<i>407</i>&nbsp;    }
<i>408</i>&nbsp;
<i>409</i>&nbsp;    /**
<i>410</i>&nbsp;     * returns true if zen discovery is started and there is a currently a background thread active for (re)joining
<i>411</i>&nbsp;     * the cluster used for testing.
<i>412</i>&nbsp;     */
<i>413</i>&nbsp;    public boolean joiningCluster() {
<b class="nc"><i>414</i>&nbsp;        return joinThreadControl.joinThreadActive();</b>
<i>415</i>&nbsp;    }
<i>416</i>&nbsp;
<i>417</i>&nbsp;    // used for testing
<i>418</i>&nbsp;    public ClusterState[] pendingClusterStates() {
<b class="nc"><i>419</i>&nbsp;        return pendingStatesQueue.pendingClusterStates();</b>
<i>420</i>&nbsp;    }
<i>421</i>&nbsp;
<i>422</i>&nbsp;    PendingClusterStatesQueue pendingClusterStatesQueue() {
<b class="nc"><i>423</i>&nbsp;        return pendingStatesQueue;</b>
<i>424</i>&nbsp;    }
<i>425</i>&nbsp;
<i>426</i>&nbsp;    /**
<i>427</i>&nbsp;     * the main function of a join thread. This function is guaranteed to join the cluster
<i>428</i>&nbsp;     * or spawn a new join thread upon failure to do so.
<i>429</i>&nbsp;     */
<i>430</i>&nbsp;    private void innerJoinCluster() {
<b class="nc"><i>431</i>&nbsp;        DiscoveryNode masterNode = null;</b>
<b class="nc"><i>432</i>&nbsp;        final Thread currentThread = Thread.currentThread();</b>
<b class="nc"><i>433</i>&nbsp;        nodeJoinController.startElectionContext();</b>
<b class="nc"><i>434</i>&nbsp;        while (masterNode == null &amp;&amp; joinThreadControl.joinThreadActive(currentThread)) {</b>
<b class="nc"><i>435</i>&nbsp;            masterNode = findMaster();</b>
<i>436</i>&nbsp;        }
<i>437</i>&nbsp;
<b class="nc"><i>438</i>&nbsp;        if (!joinThreadControl.joinThreadActive(currentThread)) {</b>
<b class="nc"><i>439</i>&nbsp;            logger.trace(&quot;thread is no longer in currentJoinThread. Stopping.&quot;);</b>
<b class="nc"><i>440</i>&nbsp;            return;</b>
<i>441</i>&nbsp;        }
<i>442</i>&nbsp;
<b class="nc"><i>443</i>&nbsp;        if (transportService.getLocalNode().equals(masterNode)) {</b>
<b class="nc"><i>444</i>&nbsp;            final int requiredJoins = Math.max(0, electMaster.minimumMasterNodes() - 1); // we count as one</b>
<b class="nc"><i>445</i>&nbsp;            logger.debug(&quot;elected as master, waiting for incoming joins ([{}] needed)&quot;, requiredJoins);</b>
<b class="nc"><i>446</i>&nbsp;            nodeJoinController.waitToBeElectedAsMaster(requiredJoins, masterElectionWaitForJoinsTimeout,</b>
<i>447</i>&nbsp;                    new NodeJoinController.ElectionCallback() {
<i>448</i>&nbsp;                        @Override
<i>449</i>&nbsp;                        public void onElectedAsMaster(ClusterState state) {
<i>450</i>&nbsp;                            synchronized (stateMutex) {
<i>451</i>&nbsp;                                joinThreadControl.markThreadAsDone(currentThread);
<i>452</i>&nbsp;                            }
<i>453</i>&nbsp;                        }
<i>454</i>&nbsp;
<i>455</i>&nbsp;                        @Override
<i>456</i>&nbsp;                        public void onFailure(Throwable t) {
<i>457</i>&nbsp;                            logger.trace(&quot;failed while waiting for nodes to join, rejoining&quot;, t);
<i>458</i>&nbsp;                            synchronized (stateMutex) {
<i>459</i>&nbsp;                                joinThreadControl.markThreadAsDoneAndStartNew(currentThread);
<i>460</i>&nbsp;                            }
<i>461</i>&nbsp;                        }
<i>462</i>&nbsp;                    }
<i>463</i>&nbsp;
<i>464</i>&nbsp;            );
<b class="nc"><i>465</i>&nbsp;        } else {</b>
<i>466</i>&nbsp;            // process any incoming joins (they will fail because we are not the master)
<b class="nc"><i>467</i>&nbsp;            nodeJoinController.stopElectionContext(masterNode + &quot; elected&quot;);</b>
<i>468</i>&nbsp;
<i>469</i>&nbsp;            // send join request
<b class="nc"><i>470</i>&nbsp;            final boolean success = joinElectedMaster(masterNode);</b>
<i>471</i>&nbsp;
<b class="nc"><i>472</i>&nbsp;            synchronized (stateMutex) {</b>
<b class="nc"><i>473</i>&nbsp;                if (success) {</b>
<b class="nc"><i>474</i>&nbsp;                    DiscoveryNode currentMasterNode = this.clusterState().getNodes().getMasterNode();</b>
<b class="nc"><i>475</i>&nbsp;                    if (currentMasterNode == null) {</b>
<i>476</i>&nbsp;                        // Post 1.3.0, the master should publish a new cluster state before acking our join request. we now should have
<i>477</i>&nbsp;                        // a valid master.
<b class="nc"><i>478</i>&nbsp;                        logger.debug(&quot;no master node is set, despite of join request completing. retrying pings.&quot;);</b>
<b class="nc"><i>479</i>&nbsp;                        joinThreadControl.markThreadAsDoneAndStartNew(currentThread);</b>
<b class="nc"><i>480</i>&nbsp;                    } else if (currentMasterNode.equals(masterNode) == false) {</b>
<i>481</i>&nbsp;                        // update cluster state
<b class="nc"><i>482</i>&nbsp;                        joinThreadControl.stopRunningThreadAndRejoin(&quot;master_switched_while_finalizing_join&quot;);</b>
<i>483</i>&nbsp;                    }
<i>484</i>&nbsp;
<b class="nc"><i>485</i>&nbsp;                    joinThreadControl.markThreadAsDone(currentThread);</b>
<b class="nc"><i>486</i>&nbsp;                } else {</b>
<i>487</i>&nbsp;                    // failed to join. Try again...
<b class="nc"><i>488</i>&nbsp;                    joinThreadControl.markThreadAsDoneAndStartNew(currentThread);</b>
<i>489</i>&nbsp;                }
<b class="nc"><i>490</i>&nbsp;            }</b>
<i>491</i>&nbsp;        }
<b class="nc"><i>492</i>&nbsp;    }</b>
<i>493</i>&nbsp;
<i>494</i>&nbsp;    /**
<i>495</i>&nbsp;     * Join a newly elected master.
<i>496</i>&nbsp;     *
<i>497</i>&nbsp;     * @return true if successful
<i>498</i>&nbsp;     */
<i>499</i>&nbsp;    private boolean joinElectedMaster(DiscoveryNode masterNode) {
<i>500</i>&nbsp;        try {
<i>501</i>&nbsp;            // first, make sure we can connect to the master
<b class="nc"><i>502</i>&nbsp;            transportService.connectToNode(masterNode);</b>
<b class="nc"><i>503</i>&nbsp;        } catch (Exception e) {</b>
<b class="nc"><i>504</i>&nbsp;            logger.warn(() -&gt; new ParameterizedMessage(&quot;failed to connect to master [{}], retrying...&quot;, masterNode), e);</b>
<b class="nc"><i>505</i>&nbsp;            return false;</b>
<b class="nc"><i>506</i>&nbsp;        }</b>
<b class="nc"><i>507</i>&nbsp;        int joinAttempt = 0; // we retry on illegal state if the master is not yet ready</b>
<i>508</i>&nbsp;        while (true) {
<i>509</i>&nbsp;            try {
<b class="nc"><i>510</i>&nbsp;                logger.trace(&quot;joining master {}&quot;, masterNode);</b>
<b class="nc"><i>511</i>&nbsp;                membership.sendJoinRequestBlocking(masterNode, transportService.getLocalNode(), joinTimeout);</b>
<b class="nc"><i>512</i>&nbsp;                return true;</b>
<b class="nc"><i>513</i>&nbsp;            } catch (Exception e) {</b>
<b class="nc"><i>514</i>&nbsp;                final Throwable unwrap = ExceptionsHelper.unwrapCause(e);</b>
<b class="nc"><i>515</i>&nbsp;                if (unwrap instanceof NotMasterException) {</b>
<b class="nc"><i>516</i>&nbsp;                    if (++joinAttempt == this.joinRetryAttempts) {</b>
<b class="nc"><i>517</i>&nbsp;                        logger.info(&quot;failed to send join request to master [{}], reason [{}], tried [{}] times&quot;, masterNode,</b>
<b class="nc"><i>518</i>&nbsp;                            ExceptionsHelper.detailedMessage(e), joinAttempt);</b>
<b class="nc"><i>519</i>&nbsp;                        return false;</b>
<i>520</i>&nbsp;                    } else {
<b class="nc"><i>521</i>&nbsp;                        logger.trace(&quot;master {} failed with [{}]. retrying... (attempts done: [{}])&quot;, masterNode,</b>
<b class="nc"><i>522</i>&nbsp;                            ExceptionsHelper.detailedMessage(e), joinAttempt);</b>
<i>523</i>&nbsp;                    }
<i>524</i>&nbsp;                } else {
<b class="nc"><i>525</i>&nbsp;                    if (logger.isTraceEnabled()) {</b>
<b class="nc"><i>526</i>&nbsp;                        logger.trace(() -&gt; new ParameterizedMessage(&quot;failed to send join request to master [{}]&quot;, masterNode), e);</b>
<i>527</i>&nbsp;                    } else {
<b class="nc"><i>528</i>&nbsp;                        logger.info(&quot;failed to send join request to master [{}], reason [{}]&quot;, masterNode,</b>
<b class="nc"><i>529</i>&nbsp;                            ExceptionsHelper.detailedMessage(e));</b>
<i>530</i>&nbsp;                    }
<b class="nc"><i>531</i>&nbsp;                    return false;</b>
<i>532</i>&nbsp;                }
<i>533</i>&nbsp;            }
<i>534</i>&nbsp;
<i>535</i>&nbsp;            try {
<b class="nc"><i>536</i>&nbsp;                Thread.sleep(this.joinRetryDelay.millis());</b>
<b class="nc"><i>537</i>&nbsp;            } catch (InterruptedException e) {</b>
<b class="nc"><i>538</i>&nbsp;                Thread.currentThread().interrupt();</b>
<b class="nc"><i>539</i>&nbsp;            }</b>
<i>540</i>&nbsp;        }
<i>541</i>&nbsp;    }
<i>542</i>&nbsp;
<i>543</i>&nbsp;    private void submitRejoin(String source) {
<b class="nc"><i>544</i>&nbsp;        synchronized (stateMutex) {</b>
<b class="nc"><i>545</i>&nbsp;            rejoin(source);</b>
<b class="nc"><i>546</i>&nbsp;        }</b>
<b class="nc"><i>547</i>&nbsp;    }</b>
<i>548</i>&nbsp;
<i>549</i>&nbsp;    // visible for testing
<i>550</i>&nbsp;    void setCommittedState(ClusterState clusterState) {
<b class="nc"><i>551</i>&nbsp;        synchronized (stateMutex) {</b>
<b class="nc"><i>552</i>&nbsp;            committedState.set(clusterState);</b>
<b class="nc"><i>553</i>&nbsp;        }</b>
<b class="nc"><i>554</i>&nbsp;    }</b>
<i>555</i>&nbsp;
<i>556</i>&nbsp;    private void removeNode(final DiscoveryNode node, final String source, final String reason) {
<b class="nc"><i>557</i>&nbsp;        masterService.submitStateUpdateTask(</b>
<i>558</i>&nbsp;                source + &quot;(&quot; + node + &quot;), reason(&quot; + reason + &quot;)&quot;,
<i>559</i>&nbsp;                new NodeRemovalClusterStateTaskExecutor.Task(node, reason),
<b class="nc"><i>560</i>&nbsp;                ClusterStateTaskConfig.build(Priority.IMMEDIATE),</b>
<i>561</i>&nbsp;                nodeRemovalExecutor,
<i>562</i>&nbsp;                nodeRemovalExecutor);
<b class="nc"><i>563</i>&nbsp;    }</b>
<i>564</i>&nbsp;
<i>565</i>&nbsp;    private void handleLeaveRequest(final DiscoveryNode node) {
<b class="nc"><i>566</i>&nbsp;        if (lifecycleState() != Lifecycle.State.STARTED) {</b>
<i>567</i>&nbsp;            // not started, ignore a node failure
<b class="nc"><i>568</i>&nbsp;            return;</b>
<i>569</i>&nbsp;        }
<b class="nc"><i>570</i>&nbsp;        if (localNodeMaster()) {</b>
<b class="nc"><i>571</i>&nbsp;            removeNode(node, &quot;zen-disco-node-left&quot;, &quot;left&quot;);</b>
<b class="nc"><i>572</i>&nbsp;        } else if (node.equals(clusterState().nodes().getMasterNode())) {</b>
<b class="nc"><i>573</i>&nbsp;            handleMasterGone(node, null, &quot;shut_down&quot;);</b>
<i>574</i>&nbsp;        }
<b class="nc"><i>575</i>&nbsp;    }</b>
<i>576</i>&nbsp;
<i>577</i>&nbsp;    private void handleNodeFailure(final DiscoveryNode node, final String reason) {
<b class="nc"><i>578</i>&nbsp;        if (lifecycleState() != Lifecycle.State.STARTED) {</b>
<i>579</i>&nbsp;            // not started, ignore a node failure
<b class="nc"><i>580</i>&nbsp;            return;</b>
<i>581</i>&nbsp;        }
<b class="nc"><i>582</i>&nbsp;        if (!localNodeMaster()) {</b>
<i>583</i>&nbsp;            // nothing to do here...
<b class="nc"><i>584</i>&nbsp;            return;</b>
<i>585</i>&nbsp;        }
<b class="nc"><i>586</i>&nbsp;        removeNode(node, &quot;zen-disco-node-failed&quot;, reason);</b>
<b class="nc"><i>587</i>&nbsp;    }</b>
<i>588</i>&nbsp;
<i>589</i>&nbsp;    private void handleMinimumMasterNodesChanged(final int minimumMasterNodes) {
<b class="nc"><i>590</i>&nbsp;        if (lifecycleState() != Lifecycle.State.STARTED) {</b>
<i>591</i>&nbsp;            // not started, ignore a node failure
<b class="nc"><i>592</i>&nbsp;            return;</b>
<i>593</i>&nbsp;        }
<b class="nc"><i>594</i>&nbsp;        final int prevMinimumMasterNode = ZenDiscovery.this.electMaster.minimumMasterNodes();</b>
<b class="nc"><i>595</i>&nbsp;        ZenDiscovery.this.electMaster.minimumMasterNodes(minimumMasterNodes);</b>
<b class="nc"><i>596</i>&nbsp;        if (!localNodeMaster()) {</b>
<i>597</i>&nbsp;            // We only set the new value. If the master doesn&#39;t see enough nodes it will revoke it&#39;s mastership.
<b class="nc"><i>598</i>&nbsp;            return;</b>
<i>599</i>&nbsp;        }
<b class="nc"><i>600</i>&nbsp;        synchronized (stateMutex) {</b>
<i>601</i>&nbsp;            // check if we have enough master nodes, if not, we need to move into joining the cluster again
<b class="nc"><i>602</i>&nbsp;            if (!electMaster.hasEnoughMasterNodes(committedState.get().nodes())) {</b>
<b class="nc"><i>603</i>&nbsp;                rejoin(&quot;not enough master nodes on change of minimum_master_nodes from [&quot; + prevMinimumMasterNode + &quot;] to [&quot; +</b>
<i>604</i>&nbsp;                    minimumMasterNodes + &quot;]&quot;);
<i>605</i>&nbsp;            }
<b class="nc"><i>606</i>&nbsp;        }</b>
<b class="nc"><i>607</i>&nbsp;    }</b>
<i>608</i>&nbsp;
<i>609</i>&nbsp;    private void handleMasterGone(final DiscoveryNode masterNode, final Throwable cause, final String reason) {
<b class="nc"><i>610</i>&nbsp;        if (lifecycleState() != Lifecycle.State.STARTED) {</b>
<i>611</i>&nbsp;            // not started, ignore a master failure
<b class="nc"><i>612</i>&nbsp;            return;</b>
<i>613</i>&nbsp;        }
<b class="nc"><i>614</i>&nbsp;        if (localNodeMaster()) {</b>
<i>615</i>&nbsp;            // we might get this on both a master telling us shutting down, and then the disconnect failure
<b class="nc"><i>616</i>&nbsp;            return;</b>
<i>617</i>&nbsp;        }
<i>618</i>&nbsp;
<b class="nc"><i>619</i>&nbsp;        logger.info(() -&gt; new ParameterizedMessage(&quot;master_left [{}], reason [{}]&quot;, masterNode, reason), cause);</b>
<i>620</i>&nbsp;
<b class="nc"><i>621</i>&nbsp;        synchronized (stateMutex) {</b>
<b class="nc"><i>622</i>&nbsp;            if (localNodeMaster() == false &amp;&amp; masterNode.equals(committedState.get().nodes().getMasterNode())) {</b>
<i>623</i>&nbsp;                // flush any pending cluster states from old master, so it will not be set as master again
<b class="nc"><i>624</i>&nbsp;                pendingStatesQueue.failAllStatesAndClear(new ElasticsearchException(&quot;master left [{}]&quot;, reason));</b>
<b class="nc"><i>625</i>&nbsp;                rejoin(&quot;master left (reason = &quot; + reason + &quot;)&quot;);</b>
<i>626</i>&nbsp;            }
<b class="nc"><i>627</i>&nbsp;        }</b>
<b class="nc"><i>628</i>&nbsp;    }</b>
<i>629</i>&nbsp;
<i>630</i>&nbsp;    // return true if state has been sent to applier
<i>631</i>&nbsp;    boolean processNextCommittedClusterState(String reason) {
<b class="nc"><i>632</i>&nbsp;        assert Thread.holdsLock(stateMutex);</b>
<i>633</i>&nbsp;
<b class="nc"><i>634</i>&nbsp;        final ClusterState newClusterState = pendingStatesQueue.getNextClusterStateToProcess();</b>
<b class="nc"><i>635</i>&nbsp;        final ClusterState currentState = committedState.get();</b>
<i>636</i>&nbsp;        // all pending states have been processed
<b class="nc"><i>637</i>&nbsp;        if (newClusterState == null) {</b>
<b class="nc"><i>638</i>&nbsp;            return false;</b>
<i>639</i>&nbsp;        }
<i>640</i>&nbsp;
<b class="nc"><i>641</i>&nbsp;        assert newClusterState.nodes().getMasterNode() != null : &quot;received a cluster state without a master&quot;;</b>
<b class="nc"><i>642</i>&nbsp;        assert !newClusterState.blocks().hasGlobalBlock(noMasterBlockService.getNoMasterBlock()) :</b>
<i>643</i>&nbsp;            &quot;received a cluster state with a master block&quot;;
<i>644</i>&nbsp;
<b class="nc"><i>645</i>&nbsp;        if (currentState.nodes().isLocalNodeElectedMaster() &amp;&amp; newClusterState.nodes().isLocalNodeElectedMaster() == false) {</b>
<b class="nc"><i>646</i>&nbsp;            handleAnotherMaster(currentState, newClusterState.nodes().getMasterNode(), newClusterState.version(),</b>
<i>647</i>&nbsp;                &quot;via a new cluster state&quot;);
<b class="nc"><i>648</i>&nbsp;            return false;</b>
<i>649</i>&nbsp;        }
<i>650</i>&nbsp;
<i>651</i>&nbsp;        try {
<b class="nc"><i>652</i>&nbsp;            if (shouldIgnoreOrRejectNewClusterState(logger, currentState, newClusterState)) {</b>
<b class="nc"><i>653</i>&nbsp;                String message = String.format(</b>
<i>654</i>&nbsp;                    Locale.ROOT,
<i>655</i>&nbsp;                    &quot;rejecting cluster state version [%d] uuid [%s] received from [%s]&quot;,
<b class="nc"><i>656</i>&nbsp;                    newClusterState.version(),</b>
<b class="nc"><i>657</i>&nbsp;                    newClusterState.stateUUID(),</b>
<b class="nc"><i>658</i>&nbsp;                    newClusterState.nodes().getMasterNodeId()</b>
<i>659</i>&nbsp;                );
<b class="nc"><i>660</i>&nbsp;                throw new IllegalStateException(message);</b>
<i>661</i>&nbsp;            }
<b class="nc"><i>662</i>&nbsp;        } catch (Exception e) {</b>
<i>663</i>&nbsp;            try {
<b class="nc"><i>664</i>&nbsp;                pendingStatesQueue.markAsFailed(newClusterState, e);</b>
<b class="nc"><i>665</i>&nbsp;            } catch (Exception inner) {</b>
<b class="nc"><i>666</i>&nbsp;                inner.addSuppressed(e);</b>
<b class="nc"><i>667</i>&nbsp;                logger.error(() -&gt; new ParameterizedMessage(&quot;unexpected exception while failing [{}]&quot;, reason), inner);</b>
<b class="nc"><i>668</i>&nbsp;            }</b>
<b class="nc"><i>669</i>&nbsp;            return false;</b>
<b class="nc"><i>670</i>&nbsp;        }</b>
<i>671</i>&nbsp;
<b class="nc"><i>672</i>&nbsp;        if (currentState.blocks().hasGlobalBlock(noMasterBlockService.getNoMasterBlock())) {</b>
<i>673</i>&nbsp;            // its a fresh update from the master as we transition from a start of not having a master to having one
<b class="nc"><i>674</i>&nbsp;            logger.debug(&quot;got first state from fresh master [{}]&quot;, newClusterState.nodes().getMasterNodeId());</b>
<i>675</i>&nbsp;        }
<i>676</i>&nbsp;
<b class="nc"><i>677</i>&nbsp;        if (currentState == newClusterState) {</b>
<b class="nc"><i>678</i>&nbsp;            return false;</b>
<i>679</i>&nbsp;        }
<i>680</i>&nbsp;
<b class="nc"><i>681</i>&nbsp;        committedState.set(newClusterState);</b>
<i>682</i>&nbsp;
<i>683</i>&nbsp;        // update failure detection only after the state has been updated to prevent race condition with handleLeaveRequest
<i>684</i>&nbsp;        // and handleNodeFailure as those check the current state to determine whether the failure is to be handled by this node
<b class="nc"><i>685</i>&nbsp;        if (newClusterState.nodes().isLocalNodeElectedMaster()) {</b>
<i>686</i>&nbsp;            // update the set of nodes to ping
<b class="nc"><i>687</i>&nbsp;            nodesFD.updateNodesAndPing(newClusterState);</b>
<i>688</i>&nbsp;        } else {
<i>689</i>&nbsp;            // check to see that we monitor the correct master of the cluster
<b class="nc"><i>690</i>&nbsp;            if (masterFD.masterNode() == null || !masterFD.masterNode().equals(newClusterState.nodes().getMasterNode())) {</b>
<b class="nc"><i>691</i>&nbsp;                masterFD.restart(newClusterState.nodes().getMasterNode(),</b>
<b class="nc"><i>692</i>&nbsp;                    &quot;new cluster state received and we are monitoring the wrong master [&quot; + masterFD.masterNode() + &quot;]&quot;);</b>
<i>693</i>&nbsp;            }
<i>694</i>&nbsp;        }
<i>695</i>&nbsp;
<b class="nc"><i>696</i>&nbsp;        clusterApplier.onNewClusterState(&quot;apply cluster state (from master [&quot; + reason + &quot;])&quot;,</b>
<i>697</i>&nbsp;            this::clusterState,
<i>698</i>&nbsp;            new ClusterApplyListener() {
<i>699</i>&nbsp;                @Override
<i>700</i>&nbsp;                public void onSuccess(String source) {
<i>701</i>&nbsp;                    try {
<i>702</i>&nbsp;                        pendingStatesQueue.markAsProcessed(newClusterState);
<i>703</i>&nbsp;                    } catch (Exception e) {
<i>704</i>&nbsp;                        onFailure(source, e);
<i>705</i>&nbsp;                    }
<i>706</i>&nbsp;                }
<i>707</i>&nbsp;
<i>708</i>&nbsp;                @Override
<i>709</i>&nbsp;                public void onFailure(String source, Exception e) {
<i>710</i>&nbsp;                    logger.error(() -&gt; new ParameterizedMessage(&quot;unexpected failure applying [{}]&quot;, reason), e);
<i>711</i>&nbsp;                    try {
<i>712</i>&nbsp;                        // TODO: use cluster state uuid instead of full cluster state so that we don&#39;t keep reference to CS around
<i>713</i>&nbsp;                        // for too long.
<i>714</i>&nbsp;                        pendingStatesQueue.markAsFailed(newClusterState, e);
<i>715</i>&nbsp;                    } catch (Exception inner) {
<i>716</i>&nbsp;                        inner.addSuppressed(e);
<i>717</i>&nbsp;                        logger.error(() -&gt; new ParameterizedMessage(&quot;unexpected exception while failing [{}]&quot;, reason), inner);
<i>718</i>&nbsp;                    }
<i>719</i>&nbsp;                }
<i>720</i>&nbsp;            });
<i>721</i>&nbsp;
<b class="nc"><i>722</i>&nbsp;        return true;</b>
<i>723</i>&nbsp;    }
<i>724</i>&nbsp;
<i>725</i>&nbsp;    /**
<i>726</i>&nbsp;     * In the case we follow an elected master the new cluster state needs to have the same elected master and
<i>727</i>&nbsp;     * the new cluster state version needs to be equal or higher than our cluster state version.
<i>728</i>&nbsp;     * If the first condition fails we reject the cluster state and throw an error.
<i>729</i>&nbsp;     * If the second condition fails we ignore the cluster state.
<i>730</i>&nbsp;     */
<i>731</i>&nbsp;    public static boolean shouldIgnoreOrRejectNewClusterState(Logger logger, ClusterState currentState, ClusterState newClusterState) {
<b class="nc"><i>732</i>&nbsp;        validateStateIsFromCurrentMaster(logger, currentState.nodes(), newClusterState);</b>
<i>733</i>&nbsp;
<i>734</i>&nbsp;        // reject cluster states that are not new from the same master
<b class="nc"><i>735</i>&nbsp;        if (currentState.supersedes(newClusterState) ||</b>
<b class="nc"><i>736</i>&nbsp;                (newClusterState.nodes().getMasterNodeId().equals(currentState.nodes().getMasterNodeId()) &amp;&amp;</b>
<b class="nc"><i>737</i>&nbsp;                    currentState.version() == newClusterState.version())) {</b>
<i>738</i>&nbsp;            // if the new state has a smaller version, and it has the same master node, then no need to process it
<b class="nc"><i>739</i>&nbsp;            logger.debug(&quot;received a cluster state that is not newer than the current one, ignoring (received {}, current {})&quot;,</b>
<b class="nc"><i>740</i>&nbsp;                newClusterState.version(), currentState.version());</b>
<b class="nc"><i>741</i>&nbsp;            return true;</b>
<i>742</i>&nbsp;        }
<i>743</i>&nbsp;
<i>744</i>&nbsp;        // reject older cluster states if we are following a master
<b class="nc"><i>745</i>&nbsp;        if (currentState.nodes().getMasterNodeId() != null &amp;&amp; newClusterState.version() &lt; currentState.version()) {</b>
<b class="nc"><i>746</i>&nbsp;            logger.debug(&quot;received a cluster state that has a lower version than the current one, ignoring (received {}, current {})&quot;,</b>
<b class="nc"><i>747</i>&nbsp;                newClusterState.version(), currentState.version());</b>
<b class="nc"><i>748</i>&nbsp;            return true;</b>
<i>749</i>&nbsp;        }
<b class="nc"><i>750</i>&nbsp;        return false;</b>
<i>751</i>&nbsp;    }
<i>752</i>&nbsp;
<i>753</i>&nbsp;    /**
<i>754</i>&nbsp;     * In the case we follow an elected master the new cluster state needs to have the same elected master
<i>755</i>&nbsp;     * This method checks for this and throws an exception if needed
<i>756</i>&nbsp;     */
<i>757</i>&nbsp;
<i>758</i>&nbsp;    public static void validateStateIsFromCurrentMaster(Logger logger, DiscoveryNodes currentNodes, ClusterState newClusterState) {
<b class="nc"><i>759</i>&nbsp;        if (currentNodes.getMasterNodeId() == null) {</b>
<b class="nc"><i>760</i>&nbsp;            return;</b>
<i>761</i>&nbsp;        }
<b class="nc"><i>762</i>&nbsp;        if (!currentNodes.getMasterNodeId().equals(newClusterState.nodes().getMasterNodeId())) {</b>
<b class="nc"><i>763</i>&nbsp;            logger.warn(&quot;received a cluster state from a different master than the current one, rejecting (received {}, current {})&quot;,</b>
<b class="nc"><i>764</i>&nbsp;                newClusterState.nodes().getMasterNode(), currentNodes.getMasterNode());</b>
<b class="nc"><i>765</i>&nbsp;            throw new IllegalStateException(&quot;cluster state from a different master than the current one, rejecting (received &quot; +</b>
<b class="nc"><i>766</i>&nbsp;                newClusterState.nodes().getMasterNode() + &quot;, current &quot; + currentNodes.getMasterNode() + &quot;)&quot;);</b>
<i>767</i>&nbsp;        }
<b class="nc"><i>768</i>&nbsp;    }</b>
<i>769</i>&nbsp;
<i>770</i>&nbsp;    void handleJoinRequest(final DiscoveryNode node, final ClusterState state, final MembershipAction.JoinCallback callback) {
<b class="nc"><i>771</i>&nbsp;        if (nodeJoinController == null) {</b>
<b class="nc"><i>772</i>&nbsp;            throw new IllegalStateException(&quot;discovery module is not yet started&quot;);</b>
<i>773</i>&nbsp;        } else {
<i>774</i>&nbsp;            // we do this in a couple of places including the cluster update thread. This one here is really just best effort
<i>775</i>&nbsp;            // to ensure we fail as fast as possible.
<b class="nc"><i>776</i>&nbsp;            onJoinValidators.stream().forEach(a -&gt; a.accept(node, state));</b>
<b class="nc"><i>777</i>&nbsp;            if (state.getBlocks().hasGlobalBlock(STATE_NOT_RECOVERED_BLOCK) == false) {</b>
<b class="nc"><i>778</i>&nbsp;                JoinTaskExecutor.ensureMajorVersionBarrier(node.getVersion(), state.getNodes().getMinNodeVersion());</b>
<i>779</i>&nbsp;            }
<i>780</i>&nbsp;            // try and connect to the node, if it fails, we can raise an exception back to the client...
<b class="nc"><i>781</i>&nbsp;            transportService.connectToNode(node);</b>
<i>782</i>&nbsp;
<i>783</i>&nbsp;            // validate the join request, will throw a failure if it fails, which will get back to the
<i>784</i>&nbsp;            // node calling the join request
<i>785</i>&nbsp;            try {
<b class="nc"><i>786</i>&nbsp;                membership.sendValidateJoinRequestBlocking(node, state, joinTimeout);</b>
<b class="nc"><i>787</i>&nbsp;            } catch (Exception e) {</b>
<b class="nc"><i>788</i>&nbsp;                logger.warn(() -&gt; new ParameterizedMessage(&quot;failed to validate incoming join request from node [{}]&quot;, node),</b>
<i>789</i>&nbsp;                    e);
<b class="nc"><i>790</i>&nbsp;                callback.onFailure(new IllegalStateException(&quot;failure when sending a validation request to node&quot;, e));</b>
<b class="nc"><i>791</i>&nbsp;                return;</b>
<b class="nc"><i>792</i>&nbsp;            }</b>
<b class="nc"><i>793</i>&nbsp;            nodeJoinController.handleJoinRequest(node, callback);</b>
<i>794</i>&nbsp;        }
<b class="nc"><i>795</i>&nbsp;    }</b>
<i>796</i>&nbsp;
<i>797</i>&nbsp;    private DiscoveryNode findMaster() {
<b class="nc"><i>798</i>&nbsp;        logger.trace(&quot;starting to ping&quot;);</b>
<b class="nc"><i>799</i>&nbsp;        List&lt;ZenPing.PingResponse&gt; fullPingResponses = pingAndWait(pingTimeout).toList();</b>
<b class="nc"><i>800</i>&nbsp;        if (fullPingResponses == null) {</b>
<b class="nc"><i>801</i>&nbsp;            logger.trace(&quot;No full ping responses&quot;);</b>
<b class="nc"><i>802</i>&nbsp;            return null;</b>
<i>803</i>&nbsp;        }
<b class="nc"><i>804</i>&nbsp;        if (logger.isTraceEnabled()) {</b>
<b class="nc"><i>805</i>&nbsp;            StringBuilder sb = new StringBuilder();</b>
<b class="nc"><i>806</i>&nbsp;            if (fullPingResponses.size() == 0) {</b>
<b class="nc"><i>807</i>&nbsp;                sb.append(&quot; {none}&quot;);</b>
<i>808</i>&nbsp;            } else {
<b class="nc"><i>809</i>&nbsp;                for (ZenPing.PingResponse pingResponse : fullPingResponses) {</b>
<b class="nc"><i>810</i>&nbsp;                    sb.append(&quot;\n\t--&gt; &quot;).append(pingResponse);</b>
<b class="nc"><i>811</i>&nbsp;                }</b>
<i>812</i>&nbsp;            }
<b class="nc"><i>813</i>&nbsp;            logger.trace(&quot;full ping responses:{}&quot;, sb);</b>
<i>814</i>&nbsp;        }
<i>815</i>&nbsp;
<b class="nc"><i>816</i>&nbsp;        final DiscoveryNode localNode = transportService.getLocalNode();</b>
<i>817</i>&nbsp;
<i>818</i>&nbsp;        // add our selves
<b class="nc"><i>819</i>&nbsp;        assert fullPingResponses.stream().map(ZenPing.PingResponse::node)</b>
<b class="nc"><i>820</i>&nbsp;            .filter(n -&gt; n.equals(localNode)).findAny().isPresent() == false;</b>
<i>821</i>&nbsp;
<b class="nc"><i>822</i>&nbsp;        fullPingResponses.add(new ZenPing.PingResponse(localNode, null, this.clusterState()));</b>
<i>823</i>&nbsp;
<i>824</i>&nbsp;        // filter responses
<b class="nc"><i>825</i>&nbsp;        final List&lt;ZenPing.PingResponse&gt; pingResponses = filterPingResponses(fullPingResponses, masterElectionIgnoreNonMasters, logger);</b>
<i>826</i>&nbsp;
<b class="nc"><i>827</i>&nbsp;        List&lt;DiscoveryNode&gt; activeMasters = new ArrayList&lt;&gt;();</b>
<b class="nc"><i>828</i>&nbsp;        for (ZenPing.PingResponse pingResponse : pingResponses) {</b>
<i>829</i>&nbsp;            // We can&#39;t include the local node in pingMasters list, otherwise we may up electing ourselves without
<i>830</i>&nbsp;            // any check / verifications from other nodes in ZenDiscover#innerJoinCluster()
<b class="nc"><i>831</i>&nbsp;            if (pingResponse.master() != null &amp;&amp; !localNode.equals(pingResponse.master())) {</b>
<b class="nc"><i>832</i>&nbsp;                activeMasters.add(pingResponse.master());</b>
<i>833</i>&nbsp;            }
<b class="nc"><i>834</i>&nbsp;        }</b>
<i>835</i>&nbsp;
<i>836</i>&nbsp;        // nodes discovered during pinging
<b class="nc"><i>837</i>&nbsp;        List&lt;ElectMasterService.MasterCandidate&gt; masterCandidates = new ArrayList&lt;&gt;();</b>
<b class="nc"><i>838</i>&nbsp;        for (ZenPing.PingResponse pingResponse : pingResponses) {</b>
<b class="nc"><i>839</i>&nbsp;            if (pingResponse.node().isMasterNode()) {</b>
<b class="nc"><i>840</i>&nbsp;                masterCandidates.add(new ElectMasterService.MasterCandidate(pingResponse.node(), pingResponse.getClusterStateVersion()));</b>
<i>841</i>&nbsp;            }
<b class="nc"><i>842</i>&nbsp;        }</b>
<i>843</i>&nbsp;
<b class="nc"><i>844</i>&nbsp;        if (activeMasters.isEmpty()) {</b>
<b class="nc"><i>845</i>&nbsp;            if (electMaster.hasEnoughCandidates(masterCandidates)) {</b>
<b class="nc"><i>846</i>&nbsp;                final ElectMasterService.MasterCandidate winner = electMaster.electMaster(masterCandidates);</b>
<b class="nc"><i>847</i>&nbsp;                logger.trace(&quot;candidate {} won election&quot;, winner);</b>
<b class="nc"><i>848</i>&nbsp;                return winner.getNode();</b>
<i>849</i>&nbsp;            } else {
<i>850</i>&nbsp;                // if we don&#39;t have enough master nodes, we bail, because there are not enough master to elect from
<b class="nc"><i>851</i>&nbsp;                logger.warn(&quot;not enough master nodes discovered during pinging (found [{}], but needed [{}]), pinging again&quot;,</b>
<b class="nc"><i>852</i>&nbsp;                            masterCandidates, electMaster.minimumMasterNodes());</b>
<b class="nc"><i>853</i>&nbsp;                return null;</b>
<i>854</i>&nbsp;            }
<i>855</i>&nbsp;        } else {
<b class="nc"><i>856</i>&nbsp;            assert !activeMasters.contains(localNode) :</b>
<i>857</i>&nbsp;                &quot;local node should never be elected as master when other nodes indicate an active master&quot;;
<i>858</i>&nbsp;            // lets tie break between discovered nodes
<b class="nc"><i>859</i>&nbsp;            return electMaster.tieBreakActiveMasters(activeMasters);</b>
<i>860</i>&nbsp;        }
<i>861</i>&nbsp;    }
<i>862</i>&nbsp;
<i>863</i>&nbsp;    static List&lt;ZenPing.PingResponse&gt; filterPingResponses(List&lt;ZenPing.PingResponse&gt; fullPingResponses,
<i>864</i>&nbsp;                                                          boolean masterElectionIgnoreNonMasters, Logger logger) {
<i>865</i>&nbsp;        List&lt;ZenPing.PingResponse&gt; pingResponses;
<b class="nc"><i>866</i>&nbsp;        if (masterElectionIgnoreNonMasters) {</b>
<b class="nc"><i>867</i>&nbsp;            pingResponses = fullPingResponses.stream().filter(ping -&gt; ping.node().isMasterNode()).collect(Collectors.toList());</b>
<i>868</i>&nbsp;        } else {
<b class="nc"><i>869</i>&nbsp;            pingResponses = fullPingResponses;</b>
<i>870</i>&nbsp;        }
<i>871</i>&nbsp;
<b class="nc"><i>872</i>&nbsp;        if (logger.isDebugEnabled()) {</b>
<b class="nc"><i>873</i>&nbsp;            StringBuilder sb = new StringBuilder();</b>
<b class="nc"><i>874</i>&nbsp;            if (pingResponses.isEmpty()) {</b>
<b class="nc"><i>875</i>&nbsp;                sb.append(&quot; {none}&quot;);</b>
<i>876</i>&nbsp;            } else {
<b class="nc"><i>877</i>&nbsp;                for (ZenPing.PingResponse pingResponse : pingResponses) {</b>
<b class="nc"><i>878</i>&nbsp;                    sb.append(&quot;\n\t--&gt; &quot;).append(pingResponse);</b>
<b class="nc"><i>879</i>&nbsp;                }</b>
<i>880</i>&nbsp;            }
<b class="nc"><i>881</i>&nbsp;            logger.debug(&quot;filtered ping responses: (ignore_non_masters [{}]){}&quot;, masterElectionIgnoreNonMasters, sb);</b>
<i>882</i>&nbsp;        }
<b class="nc"><i>883</i>&nbsp;        return pingResponses;</b>
<i>884</i>&nbsp;    }
<i>885</i>&nbsp;
<i>886</i>&nbsp;    protected void rejoin(String reason) {
<b class="nc"><i>887</i>&nbsp;        assert Thread.holdsLock(stateMutex);</b>
<b class="nc"><i>888</i>&nbsp;        ClusterState clusterState = committedState.get();</b>
<i>889</i>&nbsp;
<b class="nc"><i>890</i>&nbsp;        logger.warn(&quot;{}, current nodes: {}&quot;, reason, clusterState.nodes());</b>
<b class="nc"><i>891</i>&nbsp;        nodesFD.stop();</b>
<b class="nc"><i>892</i>&nbsp;        masterFD.stop(reason);</b>
<i>893</i>&nbsp;
<i>894</i>&nbsp;        // TODO: do we want to force a new thread if we actively removed the master? this is to give a full pinging cycle
<i>895</i>&nbsp;        // before a decision is made.
<b class="nc"><i>896</i>&nbsp;        joinThreadControl.startNewThreadIfNotRunning();</b>
<i>897</i>&nbsp;
<b class="nc"><i>898</i>&nbsp;        if (clusterState.nodes().getMasterNodeId() != null) {</b>
<i>899</i>&nbsp;            // remove block if it already exists before adding new one
<b class="nc"><i>900</i>&nbsp;            assert clusterState.blocks().hasGlobalBlockWithId(noMasterBlockService.getNoMasterBlock().id()) == false :</b>
<i>901</i>&nbsp;                &quot;NO_MASTER_BLOCK should only be added by ZenDiscovery&quot;;
<b class="nc"><i>902</i>&nbsp;            ClusterBlocks clusterBlocks = ClusterBlocks.builder().blocks(clusterState.blocks())</b>
<b class="nc"><i>903</i>&nbsp;                .addGlobalBlock(noMasterBlockService.getNoMasterBlock())</b>
<b class="nc"><i>904</i>&nbsp;                .build();</b>
<i>905</i>&nbsp;
<b class="nc"><i>906</i>&nbsp;            DiscoveryNodes discoveryNodes = new DiscoveryNodes.Builder(clusterState.nodes()).masterNodeId(null).build();</b>
<b class="nc"><i>907</i>&nbsp;            clusterState = ClusterState.builder(clusterState)</b>
<b class="nc"><i>908</i>&nbsp;                .blocks(clusterBlocks)</b>
<b class="nc"><i>909</i>&nbsp;                .nodes(discoveryNodes)</b>
<b class="nc"><i>910</i>&nbsp;                .build();</b>
<i>911</i>&nbsp;
<b class="nc"><i>912</i>&nbsp;            committedState.set(clusterState);</b>
<b class="nc"><i>913</i>&nbsp;            clusterApplier.onNewClusterState(reason, this::clusterState, (source, e) -&gt; {}); // don&#39;t wait for state to be applied</b>
<i>914</i>&nbsp;        }
<b class="nc"><i>915</i>&nbsp;    }</b>
<i>916</i>&nbsp;
<i>917</i>&nbsp;    private boolean localNodeMaster() {
<b class="nc"><i>918</i>&nbsp;        return clusterState().nodes().isLocalNodeElectedMaster();</b>
<i>919</i>&nbsp;    }
<i>920</i>&nbsp;
<i>921</i>&nbsp;    private void handleAnotherMaster(ClusterState localClusterState, final DiscoveryNode otherMaster, long otherClusterStateVersion,
<i>922</i>&nbsp;                                     String reason) {
<b class="nc"><i>923</i>&nbsp;        assert localClusterState.nodes().isLocalNodeElectedMaster() : &quot;handleAnotherMaster called but current node is not a master&quot;;</b>
<b class="nc"><i>924</i>&nbsp;        assert Thread.holdsLock(stateMutex);</b>
<i>925</i>&nbsp;
<b class="nc"><i>926</i>&nbsp;        if (otherClusterStateVersion &gt; localClusterState.version()) {</b>
<b class="nc"><i>927</i>&nbsp;            rejoin(&quot;zen-disco-discovered another master with a new cluster_state [&quot; + otherMaster + &quot;][&quot; + reason + &quot;]&quot;);</b>
<i>928</i>&nbsp;        } else {
<i>929</i>&nbsp;            // TODO: do this outside mutex
<b class="nc"><i>930</i>&nbsp;            logger.warn(&quot;discovered [{}] which is also master but with an older cluster_state, telling [{}] to rejoin the cluster ([{}])&quot;,</b>
<i>931</i>&nbsp;                otherMaster, otherMaster, reason);
<i>932</i>&nbsp;            try {
<i>933</i>&nbsp;                // make sure we&#39;re connected to this node (connect to node does nothing if we&#39;re already connected)
<i>934</i>&nbsp;                // since the network connections are asymmetric, it may be that we received a state but have disconnected from the node
<i>935</i>&nbsp;                // in the past (after a master failure, for example)
<b class="nc"><i>936</i>&nbsp;                transportService.connectToNode(otherMaster);</b>
<b class="nc"><i>937</i>&nbsp;                transportService.sendRequest(otherMaster, DISCOVERY_REJOIN_ACTION_NAME,</b>
<b class="nc"><i>938</i>&nbsp;                    new RejoinClusterRequest(localClusterState.nodes().getLocalNodeId()),</b>
<i>939</i>&nbsp;                    new EmptyTransportResponseHandler(ThreadPool.Names.SAME) {
<i>940</i>&nbsp;
<i>941</i>&nbsp;                    @Override
<i>942</i>&nbsp;                    public void handleException(TransportException exp) {
<i>943</i>&nbsp;                        logger.warn(() -&gt; new ParameterizedMessage(&quot;failed to send rejoin request to [{}]&quot;, otherMaster), exp);
<i>944</i>&nbsp;                    }
<i>945</i>&nbsp;                });
<b class="nc"><i>946</i>&nbsp;            } catch (Exception e) {</b>
<b class="nc"><i>947</i>&nbsp;                logger.warn(() -&gt; new ParameterizedMessage(&quot;failed to send rejoin request to [{}]&quot;, otherMaster), e);</b>
<b class="nc"><i>948</i>&nbsp;            }</b>
<i>949</i>&nbsp;        }
<b class="nc"><i>950</i>&nbsp;    }</b>
<i>951</i>&nbsp;
<i>952</i>&nbsp;    private ZenPing.PingCollection pingAndWait(TimeValue timeout) {
<b class="nc"><i>953</i>&nbsp;        final CompletableFuture&lt;ZenPing.PingCollection&gt; response = new CompletableFuture&lt;&gt;();</b>
<i>954</i>&nbsp;        try {
<b class="nc"><i>955</i>&nbsp;            zenPing.ping(response::complete, timeout);</b>
<b class="nc"><i>956</i>&nbsp;        } catch (Exception ex) {</b>
<i>957</i>&nbsp;            // logged later
<b class="nc"><i>958</i>&nbsp;            response.completeExceptionally(ex);</b>
<b class="nc"><i>959</i>&nbsp;        }</b>
<i>960</i>&nbsp;
<i>961</i>&nbsp;        try {
<b class="nc"><i>962</i>&nbsp;            return response.get();</b>
<b class="nc"><i>963</i>&nbsp;        } catch (InterruptedException e) {</b>
<b class="nc"><i>964</i>&nbsp;            logger.trace(&quot;pingAndWait interrupted&quot;);</b>
<b class="nc"><i>965</i>&nbsp;            return new ZenPing.PingCollection();</b>
<b class="nc"><i>966</i>&nbsp;        } catch (ExecutionException e) {</b>
<b class="nc"><i>967</i>&nbsp;            logger.warn(&quot;Ping execution failed&quot;, e);</b>
<b class="nc"><i>968</i>&nbsp;            return new ZenPing.PingCollection();</b>
<i>969</i>&nbsp;        }
<i>970</i>&nbsp;    }
<i>971</i>&nbsp;
<i>972</i>&nbsp;    @Override
<i>973</i>&nbsp;    public void onIncomingClusterState(ClusterState incomingState) {
<b class="nc"><i>974</i>&nbsp;        validateIncomingState(logger, incomingState, committedState.get());</b>
<b class="nc"><i>975</i>&nbsp;        pendingStatesQueue.addPending(incomingState);</b>
<b class="nc"><i>976</i>&nbsp;    }</b>
<i>977</i>&nbsp;
<i>978</i>&nbsp;    @Override
<i>979</i>&nbsp;    public void onClusterStateCommitted(String stateUUID, ActionListener&lt;Void&gt; processedListener) {
<b class="nc"><i>980</i>&nbsp;        final ClusterState state = pendingStatesQueue.markAsCommitted(stateUUID,</b>
<i>981</i>&nbsp;            new PendingClusterStatesQueue.StateProcessedListener() {
<i>982</i>&nbsp;                @Override
<i>983</i>&nbsp;                public void onNewClusterStateProcessed() {
<i>984</i>&nbsp;                    processedListener.onResponse(null);
<i>985</i>&nbsp;                }
<i>986</i>&nbsp;
<i>987</i>&nbsp;                @Override
<i>988</i>&nbsp;                public void onNewClusterStateFailed(Exception e) {
<i>989</i>&nbsp;                    processedListener.onFailure(e);
<i>990</i>&nbsp;                }
<i>991</i>&nbsp;            });
<b class="nc"><i>992</i>&nbsp;        if (state != null) {</b>
<b class="nc"><i>993</i>&nbsp;            synchronized (stateMutex) {</b>
<b class="nc"><i>994</i>&nbsp;                processNextCommittedClusterState(&quot;master &quot; + state.nodes().getMasterNode() +</b>
<b class="nc"><i>995</i>&nbsp;                    &quot; committed version [&quot; + state.version() + &quot;]&quot;);</b>
<b class="nc"><i>996</i>&nbsp;            }</b>
<i>997</i>&nbsp;        }
<b class="nc"><i>998</i>&nbsp;    }</b>
<i>999</i>&nbsp;
<i>1000</i>&nbsp;    /**
<i>1001</i>&nbsp;     * does simple sanity check of the incoming cluster state. Throws an exception on rejections.
<i>1002</i>&nbsp;     */
<i>1003</i>&nbsp;    static void validateIncomingState(Logger logger, ClusterState incomingState, ClusterState lastState) {
<b class="nc"><i>1004</i>&nbsp;        final ClusterName incomingClusterName = incomingState.getClusterName();</b>
<b class="nc"><i>1005</i>&nbsp;        if (!incomingClusterName.equals(lastState.getClusterName())) {</b>
<b class="nc"><i>1006</i>&nbsp;            logger.warn(&quot;received cluster state from [{}] which is also master but with a different cluster name [{}]&quot;,</b>
<b class="nc"><i>1007</i>&nbsp;                incomingState.nodes().getMasterNode(), incomingClusterName);</b>
<b class="nc"><i>1008</i>&nbsp;            throw new IllegalStateException(&quot;received state from a node that is not part of the cluster&quot;);</b>
<i>1009</i>&nbsp;        }
<b class="nc"><i>1010</i>&nbsp;        if (lastState.nodes().getLocalNode().equals(incomingState.nodes().getLocalNode()) == false) {</b>
<b class="nc"><i>1011</i>&nbsp;            logger.warn(&quot;received a cluster state from [{}] and not part of the cluster, should not happen&quot;,</b>
<b class="nc"><i>1012</i>&nbsp;                incomingState.nodes().getMasterNode());</b>
<b class="nc"><i>1013</i>&nbsp;            throw new IllegalStateException(&quot;received state with a local node that does not match the current local node&quot;);</b>
<i>1014</i>&nbsp;        }
<i>1015</i>&nbsp;
<b class="nc"><i>1016</i>&nbsp;        if (shouldIgnoreOrRejectNewClusterState(logger, lastState, incomingState)) {</b>
<b class="nc"><i>1017</i>&nbsp;            String message = String.format(</b>
<i>1018</i>&nbsp;                Locale.ROOT,
<i>1019</i>&nbsp;                &quot;rejecting cluster state version [%d] uuid [%s] received from [%s]&quot;,
<b class="nc"><i>1020</i>&nbsp;                incomingState.version(),</b>
<b class="nc"><i>1021</i>&nbsp;                incomingState.stateUUID(),</b>
<b class="nc"><i>1022</i>&nbsp;                incomingState.nodes().getMasterNodeId()</b>
<i>1023</i>&nbsp;            );
<b class="nc"><i>1024</i>&nbsp;            logger.warn(message);</b>
<b class="nc"><i>1025</i>&nbsp;            throw new IllegalStateException(message);</b>
<i>1026</i>&nbsp;        }
<i>1027</i>&nbsp;
<b class="nc"><i>1028</i>&nbsp;    }</b>
<i>1029</i>&nbsp;
<i>1030</i>&nbsp;    private class MembershipListener implements MembershipAction.MembershipListener {
<i>1031</i>&nbsp;        @Override
<i>1032</i>&nbsp;        public void onJoin(DiscoveryNode node, MembershipAction.JoinCallback callback) {
<i>1033</i>&nbsp;            handleJoinRequest(node, ZenDiscovery.this.clusterState(), callback);
<i>1034</i>&nbsp;        }
<i>1035</i>&nbsp;
<i>1036</i>&nbsp;        @Override
<i>1037</i>&nbsp;        public void onLeave(DiscoveryNode node) {
<i>1038</i>&nbsp;            handleLeaveRequest(node);
<i>1039</i>&nbsp;        }
<i>1040</i>&nbsp;    }
<i>1041</i>&nbsp;
<b class="nc"><i>1042</i>&nbsp;    private class NodeFaultDetectionListener extends NodesFaultDetection.Listener {</b>
<i>1043</i>&nbsp;
<b class="nc"><i>1044</i>&nbsp;        private final AtomicInteger pingsWhileMaster = new AtomicInteger(0);</b>
<i>1045</i>&nbsp;
<i>1046</i>&nbsp;        @Override
<i>1047</i>&nbsp;        public void onNodeFailure(DiscoveryNode node, String reason) {
<b class="nc"><i>1048</i>&nbsp;            handleNodeFailure(node, reason);</b>
<b class="nc"><i>1049</i>&nbsp;        }</b>
<i>1050</i>&nbsp;
<i>1051</i>&nbsp;        @Override
<i>1052</i>&nbsp;        public void onPingReceived(final NodesFaultDetection.PingRequest pingRequest) {
<i>1053</i>&nbsp;            // if we are master, we don&#39;t expect any fault detection from another node. If we get it
<i>1054</i>&nbsp;            // means we potentially have two masters in the cluster.
<b class="nc"><i>1055</i>&nbsp;            if (!localNodeMaster()) {</b>
<b class="nc"><i>1056</i>&nbsp;                pingsWhileMaster.set(0);</b>
<b class="nc"><i>1057</i>&nbsp;                return;</b>
<i>1058</i>&nbsp;            }
<i>1059</i>&nbsp;
<b class="nc"><i>1060</i>&nbsp;            if (pingsWhileMaster.incrementAndGet() &lt; maxPingsFromAnotherMaster) {</b>
<b class="nc"><i>1061</i>&nbsp;                logger.trace(&quot;got a ping from another master {}. current ping count: [{}]&quot;, pingRequest.masterNode(),</b>
<b class="nc"><i>1062</i>&nbsp;                    pingsWhileMaster.get());</b>
<b class="nc"><i>1063</i>&nbsp;                return;</b>
<i>1064</i>&nbsp;            }
<b class="nc"><i>1065</i>&nbsp;            logger.debug(&quot;got a ping from another master {}. resolving who should rejoin. current ping count: [{}]&quot;,</b>
<b class="nc"><i>1066</i>&nbsp;                pingRequest.masterNode(), pingsWhileMaster.get());</b>
<b class="nc"><i>1067</i>&nbsp;            synchronized (stateMutex) {</b>
<b class="nc"><i>1068</i>&nbsp;                ClusterState currentState = committedState.get();</b>
<b class="nc"><i>1069</i>&nbsp;                if (currentState.nodes().isLocalNodeElectedMaster()) {</b>
<b class="nc"><i>1070</i>&nbsp;                    pingsWhileMaster.set(0);</b>
<b class="nc"><i>1071</i>&nbsp;                    handleAnotherMaster(currentState, pingRequest.masterNode(), pingRequest.clusterStateVersion(), &quot;node fd ping&quot;);</b>
<i>1072</i>&nbsp;                }
<b class="nc"><i>1073</i>&nbsp;            }</b>
<b class="nc"><i>1074</i>&nbsp;        }</b>
<i>1075</i>&nbsp;    }
<i>1076</i>&nbsp;
<i>1077</i>&nbsp;    private class MasterNodeFailureListener implements MasterFaultDetection.Listener {
<i>1078</i>&nbsp;
<i>1079</i>&nbsp;        @Override
<i>1080</i>&nbsp;        public void onMasterFailure(DiscoveryNode masterNode, Throwable cause, String reason) {
<i>1081</i>&nbsp;            handleMasterGone(masterNode, cause, reason);
<i>1082</i>&nbsp;        }
<i>1083</i>&nbsp;    }
<i>1084</i>&nbsp;
<b class="nc"><i>1085</i>&nbsp;    public static class RejoinClusterRequest extends TransportRequest {</b>
<i>1086</i>&nbsp;
<i>1087</i>&nbsp;        private String fromNodeId;
<i>1088</i>&nbsp;
<b class="nc"><i>1089</i>&nbsp;        RejoinClusterRequest(String fromNodeId) {</b>
<b class="nc"><i>1090</i>&nbsp;            this.fromNodeId = fromNodeId;</b>
<b class="nc"><i>1091</i>&nbsp;        }</b>
<i>1092</i>&nbsp;
<i>1093</i>&nbsp;        public RejoinClusterRequest(StreamInput in) throws IOException {
<b class="nc"><i>1094</i>&nbsp;            super(in);</b>
<b class="nc"><i>1095</i>&nbsp;            fromNodeId = in.readOptionalString();</b>
<i>1096</i>&nbsp;
<b class="nc"><i>1097</i>&nbsp;        }</b>
<i>1098</i>&nbsp;
<i>1099</i>&nbsp;        @Override
<i>1100</i>&nbsp;        public void writeTo(StreamOutput out) throws IOException {
<b class="nc"><i>1101</i>&nbsp;            super.writeTo(out);</b>
<b class="nc"><i>1102</i>&nbsp;            out.writeOptionalString(fromNodeId);</b>
<b class="nc"><i>1103</i>&nbsp;        }</b>
<i>1104</i>&nbsp;    }
<i>1105</i>&nbsp;
<i>1106</i>&nbsp;    class RejoinClusterRequestHandler implements TransportRequestHandler&lt;RejoinClusterRequest&gt; {
<i>1107</i>&nbsp;        @Override
<i>1108</i>&nbsp;        public void messageReceived(final RejoinClusterRequest request, final TransportChannel channel, Task task) throws Exception {
<i>1109</i>&nbsp;            try {
<i>1110</i>&nbsp;                channel.sendResponse(TransportResponse.Empty.INSTANCE);
<i>1111</i>&nbsp;            } catch (Exception e) {
<i>1112</i>&nbsp;                logger.warn(&quot;failed to send response on rejoin cluster request handling&quot;, e);
<i>1113</i>&nbsp;            }
<i>1114</i>&nbsp;            synchronized (stateMutex) {
<i>1115</i>&nbsp;                rejoin(&quot;received a request to rejoin the cluster from [&quot; + request.fromNodeId + &quot;]&quot;);
<i>1116</i>&nbsp;            }
<i>1117</i>&nbsp;        }
<i>1118</i>&nbsp;    }
<i>1119</i>&nbsp;
<i>1120</i>&nbsp;    /**
<i>1121</i>&nbsp;     * All control of the join thread should happen under the cluster state update task thread.
<i>1122</i>&nbsp;     * This is important to make sure that the background joining process is always in sync with any cluster state updates
<i>1123</i>&nbsp;     * like master loss, failure to join, received cluster state while joining etc.
<i>1124</i>&nbsp;     */
<i>1125</i>&nbsp;    private class JoinThreadControl {
<i>1126</i>&nbsp;
<i>1127</i>&nbsp;        private final AtomicBoolean running = new AtomicBoolean(false);
<i>1128</i>&nbsp;        private final AtomicReference&lt;Thread&gt; currentJoinThread = new AtomicReference&lt;&gt;();
<i>1129</i>&nbsp;
<i>1130</i>&nbsp;        /** returns true if join thread control is started and there is currently an active join thread */
<i>1131</i>&nbsp;        public boolean joinThreadActive() {
<i>1132</i>&nbsp;            Thread currentThread = currentJoinThread.get();
<i>1133</i>&nbsp;            return running.get() &amp;&amp; currentThread != null &amp;&amp; currentThread.isAlive();
<i>1134</i>&nbsp;        }
<i>1135</i>&nbsp;
<i>1136</i>&nbsp;        /** returns true if join thread control is started and the supplied thread is the currently active joinThread */
<i>1137</i>&nbsp;        public boolean joinThreadActive(Thread joinThread) {
<i>1138</i>&nbsp;            return running.get() &amp;&amp; joinThread.equals(currentJoinThread.get());
<i>1139</i>&nbsp;        }
<i>1140</i>&nbsp;
<i>1141</i>&nbsp;        /** cleans any running joining thread and calls {@link #rejoin} */
<i>1142</i>&nbsp;        public void stopRunningThreadAndRejoin(String reason) {
<i>1143</i>&nbsp;            assert Thread.holdsLock(stateMutex);
<i>1144</i>&nbsp;            currentJoinThread.set(null);
<i>1145</i>&nbsp;            rejoin(reason);
<i>1146</i>&nbsp;        }
<i>1147</i>&nbsp;
<i>1148</i>&nbsp;        /** starts a new joining thread if there is no currently active one and join thread controlling is started */
<i>1149</i>&nbsp;        public void startNewThreadIfNotRunning() {
<i>1150</i>&nbsp;            assert Thread.holdsLock(stateMutex);
<i>1151</i>&nbsp;            if (joinThreadActive()) {
<i>1152</i>&nbsp;                return;
<i>1153</i>&nbsp;            }
<i>1154</i>&nbsp;            threadPool.generic().execute(new Runnable() {
<i>1155</i>&nbsp;                @Override
<i>1156</i>&nbsp;                public void run() {
<i>1157</i>&nbsp;                    Thread currentThread = Thread.currentThread();
<i>1158</i>&nbsp;                    if (!currentJoinThread.compareAndSet(null, currentThread)) {
<i>1159</i>&nbsp;                        return;
<i>1160</i>&nbsp;                    }
<i>1161</i>&nbsp;                    while (running.get() &amp;&amp; joinThreadActive(currentThread)) {
<i>1162</i>&nbsp;                        try {
<i>1163</i>&nbsp;                            innerJoinCluster();
<i>1164</i>&nbsp;                            return;
<i>1165</i>&nbsp;                        } catch (Exception e) {
<i>1166</i>&nbsp;                            logger.error(&quot;unexpected error while joining cluster, trying again&quot;, e);
<i>1167</i>&nbsp;                            // Because we catch any exception here, we want to know in
<i>1168</i>&nbsp;                            // tests if an uncaught exception got to this point and the test infra uncaught exception
<i>1169</i>&nbsp;                            // leak detection can catch this. In practise no uncaught exception should leak
<i>1170</i>&nbsp;                            assert ExceptionsHelper.reThrowIfNotNull(e);
<i>1171</i>&nbsp;                        }
<i>1172</i>&nbsp;                    }
<i>1173</i>&nbsp;                    // cleaning the current thread from currentJoinThread is done by explicit calls.
<i>1174</i>&nbsp;                }
<i>1175</i>&nbsp;            });
<i>1176</i>&nbsp;        }
<i>1177</i>&nbsp;
<i>1178</i>&nbsp;        /**
<i>1179</i>&nbsp;         * marks the given joinThread as completed and makes sure another thread is running (starting one if needed)
<i>1180</i>&nbsp;         * If the given thread is not the currently running join thread, the command is ignored.
<i>1181</i>&nbsp;         */
<i>1182</i>&nbsp;        public void markThreadAsDoneAndStartNew(Thread joinThread) {
<i>1183</i>&nbsp;            assert Thread.holdsLock(stateMutex);
<i>1184</i>&nbsp;            if (!markThreadAsDone(joinThread)) {
<i>1185</i>&nbsp;                return;
<i>1186</i>&nbsp;            }
<i>1187</i>&nbsp;            startNewThreadIfNotRunning();
<i>1188</i>&nbsp;        }
<i>1189</i>&nbsp;
<i>1190</i>&nbsp;        /** marks the given joinThread as completed. Returns false if the supplied thread is not the currently active join thread */
<i>1191</i>&nbsp;        public boolean markThreadAsDone(Thread joinThread) {
<i>1192</i>&nbsp;            assert Thread.holdsLock(stateMutex);
<i>1193</i>&nbsp;            return currentJoinThread.compareAndSet(joinThread, null);
<i>1194</i>&nbsp;        }
<i>1195</i>&nbsp;
<i>1196</i>&nbsp;        public void stop() {
<i>1197</i>&nbsp;            running.set(false);
<i>1198</i>&nbsp;            Thread joinThread = currentJoinThread.getAndSet(null);
<i>1199</i>&nbsp;            if (joinThread != null) {
<i>1200</i>&nbsp;                joinThread.interrupt();
<i>1201</i>&nbsp;            }
<i>1202</i>&nbsp;        }
<i>1203</i>&nbsp;
<i>1204</i>&nbsp;        public void start() {
<i>1205</i>&nbsp;            running.set(true);
<i>1206</i>&nbsp;        }
<i>1207</i>&nbsp;
<i>1208</i>&nbsp;    }
<i>1209</i>&nbsp;
<i>1210</i>&nbsp;    public final Collection&lt;BiConsumer&lt;DiscoveryNode, ClusterState&gt;&gt; getOnJoinValidators() {
<b class="nc"><i>1211</i>&nbsp;        return onJoinValidators;</b>
<i>1212</i>&nbsp;    }
<i>1213</i>&nbsp;
<i>1214</i>&nbsp;    static class ZenNodeRemovalClusterStateTaskExecutor extends NodeRemovalClusterStateTaskExecutor {
<i>1215</i>&nbsp;
<i>1216</i>&nbsp;        private final ElectMasterService electMasterService;
<i>1217</i>&nbsp;        private final Consumer&lt;String&gt; rejoin;
<i>1218</i>&nbsp;
<i>1219</i>&nbsp;        ZenNodeRemovalClusterStateTaskExecutor(
<i>1220</i>&nbsp;            final AllocationService allocationService,
<i>1221</i>&nbsp;            final ElectMasterService electMasterService,
<i>1222</i>&nbsp;            final Consumer&lt;String&gt; rejoin,
<i>1223</i>&nbsp;            final Logger logger) {
<b class="nc"><i>1224</i>&nbsp;            super(allocationService, logger);</b>
<b class="nc"><i>1225</i>&nbsp;            this.electMasterService = electMasterService;</b>
<b class="nc"><i>1226</i>&nbsp;            this.rejoin = rejoin;</b>
<b class="nc"><i>1227</i>&nbsp;        }</b>
<i>1228</i>&nbsp;
<i>1229</i>&nbsp;        @Override
<i>1230</i>&nbsp;        protected ClusterTasksResult&lt;Task&gt; getTaskClusterTasksResult(ClusterState currentState, List&lt;Task&gt; tasks,
<i>1231</i>&nbsp;                                                                     ClusterState remainingNodesClusterState) {
<b class="nc"><i>1232</i>&nbsp;            if (electMasterService.hasEnoughMasterNodes(remainingNodesClusterState.nodes()) == false) {</b>
<b class="nc"><i>1233</i>&nbsp;                final ClusterTasksResult.Builder&lt;Task&gt; resultBuilder = ClusterTasksResult.&lt;Task&gt;builder().successes(tasks);</b>
<b class="nc"><i>1234</i>&nbsp;                final int masterNodes = electMasterService.countMasterNodes(remainingNodesClusterState.nodes());</b>
<b class="nc"><i>1235</i>&nbsp;                rejoin.accept(LoggerMessageFormat.format(&quot;not enough master nodes (has [{}], but needed [{}])&quot;,</b>
<b class="nc"><i>1236</i>&nbsp;                    masterNodes, electMasterService.minimumMasterNodes()));</b>
<b class="nc"><i>1237</i>&nbsp;                return resultBuilder.build(currentState);</b>
<i>1238</i>&nbsp;            } else {
<b class="nc"><i>1239</i>&nbsp;                return super.getTaskClusterTasksResult(currentState, tasks, remainingNodesClusterState);</b>
<i>1240</i>&nbsp;            }
<i>1241</i>&nbsp;        }
<i>1242</i>&nbsp;    }
<i>1243</i>&nbsp;}
</div>
</div>

<div class="footer">
    
    <div style="float:right;">generated on 2020-02-09 18:45</div>
</div>
</body>
</html>
