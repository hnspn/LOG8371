


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html id="htmlId">
<head>
  <title>Coverage Report :: PeerRecoveryTargetService</title>
  <style type="text/css">
    @import "../../.css/coverage.css";
  </style>
</head>

<body>
<div class="header"></div>

<div class="content">
<div class="breadCrumbs">
    [ <a href="../../index.html">all classes</a> ]
    [ <a href="../index.html">org.elasticsearch.indices.recovery</a> ]
</div>

<h1>Coverage Summary for Class: PeerRecoveryTargetService (org.elasticsearch.indices.recovery)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">PeerRecoveryTargetService</td>
<td class="coverageStat">
  <span class="percent">
    28.6%
  </span>
  <span class="absValue">
    (4/ 14)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    14.8%
  </span>
  <span class="absValue">
    (19/ 128)
  </span>
</td>
</tr>
  <tr>
    <td class="name">PeerRecoveryTargetService$CleanFilesRequestHandler</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    14.3%
  </span>
  <span class="absValue">
    (1/ 7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">PeerRecoveryTargetService$FileChunkTransportRequestHandler</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    10%
  </span>
  <span class="absValue">
    (2/ 20)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">PeerRecoveryTargetService$FilesInfoRequestHandler</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    14.3%
  </span>
  <span class="absValue">
    (1/ 7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">PeerRecoveryTargetService$FinalizeRecoveryRequestHandler</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    14.3%
  </span>
  <span class="absValue">
    (1/ 7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">PeerRecoveryTargetService$HandoffPrimaryContextRequestHandler</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    16.7%
  </span>
  <span class="absValue">
    (1/ 6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">PeerRecoveryTargetService$PrepareForTranslogOperationsRequestHandler</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    14.3%
  </span>
  <span class="absValue">
    (1/ 7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">PeerRecoveryTargetService$RecoveryListener</td>
  </tr>
  <tr>
    <td class="name">PeerRecoveryTargetService$TranslogOperationsRequestHandler</td>
<td class="coverageStat">
  <span class="percent">
    20%
  </span>
  <span class="absValue">
    (1/ 5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    3.7%
  </span>
  <span class="absValue">
    (1/ 27)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>total</strong></td>
<td class="coverageStat">
  <span class="percent">
    35.5%
  </span>
  <span class="absValue">
    (11/ 31)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    12.9%
  </span>
  <span class="absValue">
    (27/ 209)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<div class="sourceCode"><i>1</i>&nbsp;/*
<i>2</i>&nbsp; * Licensed to Elasticsearch under one or more contributor
<i>3</i>&nbsp; * license agreements. See the NOTICE file distributed with
<i>4</i>&nbsp; * this work for additional information regarding copyright
<i>5</i>&nbsp; * ownership. Elasticsearch licenses this file to you under
<i>6</i>&nbsp; * the Apache License, Version 2.0 (the &quot;License&quot;); you may
<i>7</i>&nbsp; * not use this file except in compliance with the License.
<i>8</i>&nbsp; * You may obtain a copy of the License at
<i>9</i>&nbsp; *
<i>10</i>&nbsp; *    http://www.apache.org/licenses/LICENSE-2.0
<i>11</i>&nbsp; *
<i>12</i>&nbsp; * Unless required by applicable law or agreed to in writing,
<i>13</i>&nbsp; * software distributed under the License is distributed on an
<i>14</i>&nbsp; * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
<i>15</i>&nbsp; * KIND, either express or implied.  See the License for the
<i>16</i>&nbsp; * specific language governing permissions and limitations
<i>17</i>&nbsp; * under the License.
<i>18</i>&nbsp; */
<i>19</i>&nbsp;
<i>20</i>&nbsp;package org.elasticsearch.indices.recovery;
<i>21</i>&nbsp;
<i>22</i>&nbsp;import org.apache.logging.log4j.LogManager;
<i>23</i>&nbsp;import org.apache.logging.log4j.Logger;
<i>24</i>&nbsp;import org.apache.logging.log4j.message.ParameterizedMessage;
<i>25</i>&nbsp;import org.apache.lucene.store.AlreadyClosedException;
<i>26</i>&nbsp;import org.apache.lucene.store.RateLimiter;
<i>27</i>&nbsp;import org.elasticsearch.ElasticsearchException;
<i>28</i>&nbsp;import org.elasticsearch.ElasticsearchTimeoutException;
<i>29</i>&nbsp;import org.elasticsearch.ExceptionsHelper;
<i>30</i>&nbsp;import org.elasticsearch.action.ActionListener;
<i>31</i>&nbsp;import org.elasticsearch.action.support.ChannelActionListener;
<i>32</i>&nbsp;import org.elasticsearch.cluster.ClusterState;
<i>33</i>&nbsp;import org.elasticsearch.cluster.ClusterStateObserver;
<i>34</i>&nbsp;import org.elasticsearch.cluster.metadata.IndexMetaData;
<i>35</i>&nbsp;import org.elasticsearch.cluster.node.DiscoveryNode;
<i>36</i>&nbsp;import org.elasticsearch.cluster.service.ClusterService;
<i>37</i>&nbsp;import org.elasticsearch.common.Nullable;
<i>38</i>&nbsp;import org.elasticsearch.common.io.stream.StreamInput;
<i>39</i>&nbsp;import org.elasticsearch.common.settings.Settings;
<i>40</i>&nbsp;import org.elasticsearch.common.unit.ByteSizeValue;
<i>41</i>&nbsp;import org.elasticsearch.common.unit.TimeValue;
<i>42</i>&nbsp;import org.elasticsearch.common.util.CancellableThreads;
<i>43</i>&nbsp;import org.elasticsearch.common.util.concurrent.AbstractRunnable;
<i>44</i>&nbsp;import org.elasticsearch.index.IndexNotFoundException;
<i>45</i>&nbsp;import org.elasticsearch.index.engine.RecoveryEngineException;
<i>46</i>&nbsp;import org.elasticsearch.index.mapper.MapperException;
<i>47</i>&nbsp;import org.elasticsearch.index.shard.IllegalIndexShardStateException;
<i>48</i>&nbsp;import org.elasticsearch.index.shard.IndexEventListener;
<i>49</i>&nbsp;import org.elasticsearch.index.shard.IndexShard;
<i>50</i>&nbsp;import org.elasticsearch.index.shard.ShardId;
<i>51</i>&nbsp;import org.elasticsearch.index.shard.ShardNotFoundException;
<i>52</i>&nbsp;import org.elasticsearch.index.store.Store;
<i>53</i>&nbsp;import org.elasticsearch.index.translog.Translog;
<i>54</i>&nbsp;import org.elasticsearch.index.translog.TranslogCorruptedException;
<i>55</i>&nbsp;import org.elasticsearch.indices.recovery.RecoveriesCollection.RecoveryRef;
<i>56</i>&nbsp;import org.elasticsearch.tasks.Task;
<i>57</i>&nbsp;import org.elasticsearch.threadpool.ThreadPool;
<i>58</i>&nbsp;import org.elasticsearch.transport.ConnectTransportException;
<i>59</i>&nbsp;import org.elasticsearch.transport.TransportChannel;
<i>60</i>&nbsp;import org.elasticsearch.transport.TransportException;
<i>61</i>&nbsp;import org.elasticsearch.transport.TransportRequestHandler;
<i>62</i>&nbsp;import org.elasticsearch.transport.TransportResponse;
<i>63</i>&nbsp;import org.elasticsearch.transport.TransportResponseHandler;
<i>64</i>&nbsp;import org.elasticsearch.transport.TransportService;
<i>65</i>&nbsp;
<i>66</i>&nbsp;import java.io.IOException;
<i>67</i>&nbsp;import java.util.concurrent.atomic.AtomicLong;
<i>68</i>&nbsp;import java.util.function.Consumer;
<i>69</i>&nbsp;
<i>70</i>&nbsp;import static org.elasticsearch.common.unit.TimeValue.timeValueMillis;
<i>71</i>&nbsp;import static org.elasticsearch.index.seqno.SequenceNumbers.UNASSIGNED_SEQ_NO;
<i>72</i>&nbsp;
<i>73</i>&nbsp;/**
<i>74</i>&nbsp; * The recovery target handles recoveries of peer shards of the shard+node to recover to.
<i>75</i>&nbsp; * &lt;p&gt;
<i>76</i>&nbsp; * Note, it can be safely assumed that there will only be a single recovery per shard (index+id) and
<i>77</i>&nbsp; * not several of them (since we don&#39;t allocate several shard replicas to the same node).
<i>78</i>&nbsp; */
<b class="fc"><i>79</i>&nbsp;public class PeerRecoveryTargetService implements IndexEventListener {</b>
<i>80</i>&nbsp;
<b class="fc"><i>81</i>&nbsp;    private static final Logger logger = LogManager.getLogger(PeerRecoveryTargetService.class);</b>
<i>82</i>&nbsp;
<i>83</i>&nbsp;    public static class Actions {
<i>84</i>&nbsp;        public static final String FILES_INFO = &quot;internal:index/shard/recovery/filesInfo&quot;;
<i>85</i>&nbsp;        public static final String FILE_CHUNK = &quot;internal:index/shard/recovery/file_chunk&quot;;
<i>86</i>&nbsp;        public static final String CLEAN_FILES = &quot;internal:index/shard/recovery/clean_files&quot;;
<i>87</i>&nbsp;        public static final String TRANSLOG_OPS = &quot;internal:index/shard/recovery/translog_ops&quot;;
<i>88</i>&nbsp;        public static final String PREPARE_TRANSLOG = &quot;internal:index/shard/recovery/prepare_translog&quot;;
<i>89</i>&nbsp;        public static final String FINALIZE = &quot;internal:index/shard/recovery/finalize&quot;;
<i>90</i>&nbsp;        public static final String HANDOFF_PRIMARY_CONTEXT = &quot;internal:index/shard/recovery/handoff_primary_context&quot;;
<i>91</i>&nbsp;    }
<i>92</i>&nbsp;
<i>93</i>&nbsp;    private final ThreadPool threadPool;
<i>94</i>&nbsp;
<i>95</i>&nbsp;    private final TransportService transportService;
<i>96</i>&nbsp;
<i>97</i>&nbsp;    private final RecoverySettings recoverySettings;
<i>98</i>&nbsp;    private final ClusterService clusterService;
<i>99</i>&nbsp;
<i>100</i>&nbsp;    private final RecoveriesCollection onGoingRecoveries;
<i>101</i>&nbsp;
<i>102</i>&nbsp;    public PeerRecoveryTargetService(ThreadPool threadPool, TransportService transportService,
<b class="fc"><i>103</i>&nbsp;            RecoverySettings recoverySettings, ClusterService clusterService) {</b>
<b class="fc"><i>104</i>&nbsp;        this.threadPool = threadPool;</b>
<b class="fc"><i>105</i>&nbsp;        this.transportService = transportService;</b>
<b class="fc"><i>106</i>&nbsp;        this.recoverySettings = recoverySettings;</b>
<b class="fc"><i>107</i>&nbsp;        this.clusterService = clusterService;</b>
<b class="fc"><i>108</i>&nbsp;        this.onGoingRecoveries = new RecoveriesCollection(logger, threadPool);</b>
<i>109</i>&nbsp;
<b class="fc"><i>110</i>&nbsp;        transportService.registerRequestHandler(Actions.FILES_INFO, ThreadPool.Names.GENERIC, RecoveryFilesInfoRequest::new,</b>
<i>111</i>&nbsp;            new FilesInfoRequestHandler());
<b class="fc"><i>112</i>&nbsp;        transportService.registerRequestHandler(Actions.FILE_CHUNK, ThreadPool.Names.GENERIC, RecoveryFileChunkRequest::new,</b>
<i>113</i>&nbsp;            new FileChunkTransportRequestHandler());
<b class="fc"><i>114</i>&nbsp;        transportService.registerRequestHandler(Actions.CLEAN_FILES, ThreadPool.Names.GENERIC,</b>
<i>115</i>&nbsp;            RecoveryCleanFilesRequest::new, new CleanFilesRequestHandler());
<b class="fc"><i>116</i>&nbsp;        transportService.registerRequestHandler(Actions.PREPARE_TRANSLOG, ThreadPool.Names.GENERIC,</b>
<i>117</i>&nbsp;                RecoveryPrepareForTranslogOperationsRequest::new, new PrepareForTranslogOperationsRequestHandler());
<b class="fc"><i>118</i>&nbsp;        transportService.registerRequestHandler(Actions.TRANSLOG_OPS, ThreadPool.Names.GENERIC, RecoveryTranslogOperationsRequest::new,</b>
<i>119</i>&nbsp;            new TranslogOperationsRequestHandler());
<b class="fc"><i>120</i>&nbsp;        transportService.registerRequestHandler(Actions.FINALIZE, ThreadPool.Names.GENERIC, RecoveryFinalizeRecoveryRequest::new,</b>
<i>121</i>&nbsp;            new FinalizeRecoveryRequestHandler());
<b class="fc"><i>122</i>&nbsp;        transportService.registerRequestHandler(</b>
<i>123</i>&nbsp;                Actions.HANDOFF_PRIMARY_CONTEXT,
<i>124</i>&nbsp;                ThreadPool.Names.GENERIC,
<i>125</i>&nbsp;                RecoveryHandoffPrimaryContextRequest::new,
<i>126</i>&nbsp;                new HandoffPrimaryContextRequestHandler());
<b class="fc"><i>127</i>&nbsp;    }</b>
<i>128</i>&nbsp;
<i>129</i>&nbsp;    @Override
<i>130</i>&nbsp;    public void beforeIndexShardClosed(ShardId shardId, @Nullable IndexShard indexShard, Settings indexSettings) {
<b class="fc"><i>131</i>&nbsp;        if (indexShard != null) {</b>
<b class="fc"><i>132</i>&nbsp;            onGoingRecoveries.cancelRecoveriesForShard(shardId, &quot;shard closed&quot;);</b>
<i>133</i>&nbsp;        }
<b class="fc"><i>134</i>&nbsp;    }</b>
<i>135</i>&nbsp;
<i>136</i>&nbsp;    public void startRecovery(final IndexShard indexShard, final DiscoveryNode sourceNode, final RecoveryListener listener) {
<i>137</i>&nbsp;        // create a new recovery status, and process...
<b class="nc"><i>138</i>&nbsp;        final long recoveryId = onGoingRecoveries.startRecovery(indexShard, sourceNode, listener, recoverySettings.activityTimeout());</b>
<i>139</i>&nbsp;        // we fork off quickly here and go async but this is called from the cluster state applier thread too and that can cause
<i>140</i>&nbsp;        // assertions to trip if we executed it on the same thread hence we fork off to the generic threadpool.
<b class="nc"><i>141</i>&nbsp;        threadPool.generic().execute(new RecoveryRunner(recoveryId));</b>
<b class="nc"><i>142</i>&nbsp;    }</b>
<i>143</i>&nbsp;
<i>144</i>&nbsp;    protected void retryRecovery(final long recoveryId, final Throwable reason, TimeValue retryAfter, TimeValue activityTimeout) {
<b class="nc"><i>145</i>&nbsp;        logger.trace(() -&gt; new ParameterizedMessage(</b>
<b class="nc"><i>146</i>&nbsp;                &quot;will retry recovery with id [{}] in [{}]&quot;, recoveryId, retryAfter), reason);</b>
<b class="nc"><i>147</i>&nbsp;        retryRecovery(recoveryId, retryAfter, activityTimeout);</b>
<b class="nc"><i>148</i>&nbsp;    }</b>
<i>149</i>&nbsp;
<i>150</i>&nbsp;    protected void retryRecovery(final long recoveryId, final String reason, TimeValue retryAfter, TimeValue activityTimeout) {
<b class="nc"><i>151</i>&nbsp;        logger.trace(&quot;will retry recovery with id [{}] in [{}] (reason [{}])&quot;, recoveryId, retryAfter, reason);</b>
<b class="nc"><i>152</i>&nbsp;        retryRecovery(recoveryId, retryAfter, activityTimeout);</b>
<b class="nc"><i>153</i>&nbsp;    }</b>
<i>154</i>&nbsp;
<i>155</i>&nbsp;    private void retryRecovery(final long recoveryId, final TimeValue retryAfter, final TimeValue activityTimeout) {
<b class="nc"><i>156</i>&nbsp;        RecoveryTarget newTarget = onGoingRecoveries.resetRecovery(recoveryId, activityTimeout);</b>
<b class="nc"><i>157</i>&nbsp;        if (newTarget != null) {</b>
<b class="nc"><i>158</i>&nbsp;            threadPool.schedule(new RecoveryRunner(newTarget.recoveryId()), retryAfter, ThreadPool.Names.GENERIC);</b>
<i>159</i>&nbsp;        }
<b class="nc"><i>160</i>&nbsp;    }</b>
<i>161</i>&nbsp;
<i>162</i>&nbsp;    private void doRecovery(final long recoveryId) {
<i>163</i>&nbsp;        final StartRecoveryRequest request;
<i>164</i>&nbsp;        final RecoveryState.Timer timer;
<i>165</i>&nbsp;        CancellableThreads cancellableThreads;
<b class="nc"><i>166</i>&nbsp;        try (RecoveryRef recoveryRef = onGoingRecoveries.getRecovery(recoveryId)) {</b>
<b class="nc"><i>167</i>&nbsp;            if (recoveryRef == null) {</b>
<b class="nc"><i>168</i>&nbsp;                logger.trace(&quot;not running recovery with id [{}] - can not find it (probably finished)&quot;, recoveryId);</b>
<b class="nc"><i>169</i>&nbsp;                return;</b>
<i>170</i>&nbsp;            }
<b class="nc"><i>171</i>&nbsp;            final RecoveryTarget recoveryTarget = recoveryRef.target();</b>
<b class="nc"><i>172</i>&nbsp;            timer = recoveryTarget.state().getTimer();</b>
<b class="nc"><i>173</i>&nbsp;            cancellableThreads = recoveryTarget.cancellableThreads();</b>
<i>174</i>&nbsp;            try {
<b class="nc"><i>175</i>&nbsp;                assert recoveryTarget.sourceNode() != null : &quot;can not do a recovery without a source node&quot;;</b>
<b class="nc"><i>176</i>&nbsp;                logger.trace(&quot;{} preparing shard for peer recovery&quot;, recoveryTarget.shardId());</b>
<b class="nc"><i>177</i>&nbsp;                recoveryTarget.indexShard().prepareForIndexRecovery();</b>
<b class="nc"><i>178</i>&nbsp;                final long startingSeqNo = recoveryTarget.indexShard().recoverLocallyUpToGlobalCheckpoint();</b>
<b class="nc"><i>179</i>&nbsp;                assert startingSeqNo == UNASSIGNED_SEQ_NO || recoveryTarget.state().getStage() == RecoveryState.Stage.TRANSLOG :</b>
<b class="nc"><i>180</i>&nbsp;                    &quot;unexpected recovery stage [&quot; + recoveryTarget.state().getStage() + &quot;] starting seqno [ &quot; + startingSeqNo + &quot;]&quot;;</b>
<b class="nc"><i>181</i>&nbsp;                request = getStartRecoveryRequest(logger, clusterService.localNode(), recoveryTarget, startingSeqNo);</b>
<b class="nc"><i>182</i>&nbsp;            } catch (final Exception e) {</b>
<i>183</i>&nbsp;                // this will be logged as warning later on...
<b class="nc"><i>184</i>&nbsp;                logger.trace(&quot;unexpected error while preparing shard for peer recovery, failing recovery&quot;, e);</b>
<b class="nc"><i>185</i>&nbsp;                onGoingRecoveries.failRecovery(recoveryId,</b>
<b class="nc"><i>186</i>&nbsp;                    new RecoveryFailedException(recoveryTarget.state(), &quot;failed to prepare shard for recovery&quot;, e), true);</b>
<b class="nc"><i>187</i>&nbsp;                return;</b>
<b class="nc"><i>188</i>&nbsp;            }</b>
<b class="nc"><i>189</i>&nbsp;        }</b>
<b class="nc"><i>190</i>&nbsp;        Consumer&lt;Exception&gt; handleException = e -&gt; {</b>
<b class="nc"><i>191</i>&nbsp;            if (logger.isTraceEnabled()) {</b>
<b class="nc"><i>192</i>&nbsp;                logger.trace(() -&gt; new ParameterizedMessage(</b>
<b class="nc"><i>193</i>&nbsp;                    &quot;[{}][{}] Got exception on recovery&quot;, request.shardId().getIndex().getName(),</b>
<b class="nc"><i>194</i>&nbsp;                    request.shardId().id()), e);</b>
<i>195</i>&nbsp;            }
<b class="nc"><i>196</i>&nbsp;            Throwable cause = ExceptionsHelper.unwrapCause(e);</b>
<b class="nc"><i>197</i>&nbsp;            if (cause instanceof CancellableThreads.ExecutionCancelledException) {</b>
<i>198</i>&nbsp;                // this can also come from the source wrapped in a RemoteTransportException
<b class="nc"><i>199</i>&nbsp;                onGoingRecoveries.failRecovery(recoveryId, new RecoveryFailedException(request,</b>
<i>200</i>&nbsp;                    &quot;source has canceled the recovery&quot;, cause), false);
<b class="nc"><i>201</i>&nbsp;                return;</b>
<i>202</i>&nbsp;            }
<b class="nc"><i>203</i>&nbsp;            if (cause instanceof RecoveryEngineException) {</b>
<i>204</i>&nbsp;                // unwrap an exception that was thrown as part of the recovery
<b class="nc"><i>205</i>&nbsp;                cause = cause.getCause();</b>
<i>206</i>&nbsp;            }
<i>207</i>&nbsp;            // do it twice, in case we have double transport exception
<b class="nc"><i>208</i>&nbsp;            cause = ExceptionsHelper.unwrapCause(cause);</b>
<b class="nc"><i>209</i>&nbsp;            if (cause instanceof RecoveryEngineException) {</b>
<i>210</i>&nbsp;                // unwrap an exception that was thrown as part of the recovery
<b class="nc"><i>211</i>&nbsp;                cause = cause.getCause();</b>
<i>212</i>&nbsp;            }
<i>213</i>&nbsp;
<i>214</i>&nbsp;            // here, we would add checks against exception that need to be retried (and not removeAndClean in this case)
<i>215</i>&nbsp;
<b class="nc"><i>216</i>&nbsp;            if (cause instanceof IllegalIndexShardStateException || cause instanceof IndexNotFoundException ||</b>
<i>217</i>&nbsp;                cause instanceof ShardNotFoundException) {
<i>218</i>&nbsp;                // if the target is not ready yet, retry
<b class="nc"><i>219</i>&nbsp;                retryRecovery(</b>
<i>220</i>&nbsp;                    recoveryId,
<i>221</i>&nbsp;                    &quot;remote shard not ready&quot;,
<b class="nc"><i>222</i>&nbsp;                    recoverySettings.retryDelayStateSync(),</b>
<b class="nc"><i>223</i>&nbsp;                    recoverySettings.activityTimeout());</b>
<b class="nc"><i>224</i>&nbsp;                return;</b>
<i>225</i>&nbsp;            }
<i>226</i>&nbsp;
<b class="nc"><i>227</i>&nbsp;            if (cause instanceof DelayRecoveryException) {</b>
<b class="nc"><i>228</i>&nbsp;                retryRecovery(recoveryId, cause, recoverySettings.retryDelayStateSync(),</b>
<b class="nc"><i>229</i>&nbsp;                    recoverySettings.activityTimeout());</b>
<b class="nc"><i>230</i>&nbsp;                return;</b>
<i>231</i>&nbsp;            }
<i>232</i>&nbsp;
<b class="nc"><i>233</i>&nbsp;            if (cause instanceof ConnectTransportException) {</b>
<b class="nc"><i>234</i>&nbsp;                logger.debug(&quot;delaying recovery of {} for [{}] due to networking error [{}]&quot;, request.shardId(),</b>
<b class="nc"><i>235</i>&nbsp;                    recoverySettings.retryDelayNetwork(), cause.getMessage());</b>
<b class="nc"><i>236</i>&nbsp;                retryRecovery(recoveryId, cause.getMessage(), recoverySettings.retryDelayNetwork(),</b>
<b class="nc"><i>237</i>&nbsp;                    recoverySettings.activityTimeout());</b>
<b class="nc"><i>238</i>&nbsp;                return;</b>
<i>239</i>&nbsp;            }
<i>240</i>&nbsp;
<b class="nc"><i>241</i>&nbsp;            if (cause instanceof AlreadyClosedException) {</b>
<b class="nc"><i>242</i>&nbsp;                onGoingRecoveries.failRecovery(recoveryId,</b>
<i>243</i>&nbsp;                    new RecoveryFailedException(request, &quot;source shard is closed&quot;, cause), false);
<b class="nc"><i>244</i>&nbsp;                return;</b>
<i>245</i>&nbsp;            }
<i>246</i>&nbsp;
<b class="nc"><i>247</i>&nbsp;            onGoingRecoveries.failRecovery(recoveryId, new RecoveryFailedException(request, e), true);</b>
<b class="nc"><i>248</i>&nbsp;        };</b>
<i>249</i>&nbsp;
<i>250</i>&nbsp;        try {
<b class="nc"><i>251</i>&nbsp;            logger.trace(&quot;{} starting recovery from {}&quot;, request.shardId(), request.sourceNode());</b>
<b class="nc"><i>252</i>&nbsp;            cancellableThreads.executeIO(() -&gt;</b>
<i>253</i>&nbsp;                // we still execute under cancelableThreads here to ensure we interrupt any blocking call to the network if any
<i>254</i>&nbsp;                // on the underlying transport. It&#39;s unclear if we need this here at all after moving to async execution but
<i>255</i>&nbsp;                // the issues that a missing call to this could cause are sneaky and hard to debug. If we don&#39;t need it on this
<i>256</i>&nbsp;                // call we can potentially remove it altogether which we should do it in a major release only with enough
<i>257</i>&nbsp;                // time to test. This shoudl be done for 7.0 if possible
<b class="nc"><i>258</i>&nbsp;                transportService.submitRequest(request.sourceNode(), PeerRecoverySourceService.Actions.START_RECOVERY, request,</b>
<i>259</i>&nbsp;                    new TransportResponseHandler&lt;RecoveryResponse&gt;() {
<i>260</i>&nbsp;                        @Override
<i>261</i>&nbsp;                        public void handleResponse(RecoveryResponse recoveryResponse) {
<i>262</i>&nbsp;                            final TimeValue recoveryTime = new TimeValue(timer.time());
<i>263</i>&nbsp;                            // do this through ongoing recoveries to remove it from the collection
<i>264</i>&nbsp;                            onGoingRecoveries.markRecoveryAsDone(recoveryId);
<i>265</i>&nbsp;                            if (logger.isTraceEnabled()) {
<i>266</i>&nbsp;                                StringBuilder sb = new StringBuilder();
<i>267</i>&nbsp;                                sb.append(&#39;[&#39;).append(request.shardId().getIndex().getName()).append(&#39;]&#39;)
<i>268</i>&nbsp;                                    .append(&#39;[&#39;).append(request.shardId().id()).append(&quot;] &quot;);
<i>269</i>&nbsp;                                sb.append(&quot;recovery completed from &quot;).append(request.sourceNode()).append(&quot;, took[&quot;).append(recoveryTime)
<i>270</i>&nbsp;                                    .append(&quot;]\n&quot;);
<i>271</i>&nbsp;                                sb.append(&quot;   phase1: recovered_files [&quot;).append(recoveryResponse.phase1FileNames.size()).append(&quot;]&quot;)
<i>272</i>&nbsp;                                    .append(&quot; with total_size of [&quot;).append(new ByteSizeValue(recoveryResponse.phase1TotalSize)).append(&quot;]&quot;)
<i>273</i>&nbsp;                                    .append(&quot;, took [&quot;).append(timeValueMillis(recoveryResponse.phase1Time)).append(&quot;], throttling_wait [&quot;)
<i>274</i>&nbsp;                                    .append(timeValueMillis(recoveryResponse.phase1ThrottlingWaitTime)).append(&#39;]&#39;).append(&quot;\n&quot;);
<i>275</i>&nbsp;                                sb.append(&quot;         : reusing_files   [&quot;).append(recoveryResponse.phase1ExistingFileNames.size())
<i>276</i>&nbsp;                                    .append(&quot;] with total_size of [&quot;).append(new ByteSizeValue(recoveryResponse.phase1ExistingTotalSize))
<i>277</i>&nbsp;                                    .append(&quot;]\n&quot;);
<i>278</i>&nbsp;                                sb.append(&quot;   phase2: start took [&quot;).append(timeValueMillis(recoveryResponse.startTime)).append(&quot;]\n&quot;);
<i>279</i>&nbsp;                                sb.append(&quot;         : recovered [&quot;).append(recoveryResponse.phase2Operations).append(&quot;]&quot;)
<i>280</i>&nbsp;                                    .append(&quot; transaction log operations&quot;)
<i>281</i>&nbsp;                                    .append(&quot;, took [&quot;).append(timeValueMillis(recoveryResponse.phase2Time)).append(&quot;]&quot;)
<i>282</i>&nbsp;                                    .append(&quot;\n&quot;);
<i>283</i>&nbsp;                                logger.trace(&quot;{}&quot;, sb);
<i>284</i>&nbsp;                            } else {
<i>285</i>&nbsp;                                logger.debug(&quot;{} recovery done from [{}], took [{}]&quot;, request.shardId(), request.sourceNode(),
<i>286</i>&nbsp;                                    recoveryTime);
<i>287</i>&nbsp;                            }
<i>288</i>&nbsp;                        }
<i>289</i>&nbsp;
<i>290</i>&nbsp;                        @Override
<i>291</i>&nbsp;                        public void handleException(TransportException e) {
<i>292</i>&nbsp;                            handleException.accept(e);
<i>293</i>&nbsp;                        }
<i>294</i>&nbsp;
<i>295</i>&nbsp;                        @Override
<i>296</i>&nbsp;                        public String executor() {
<i>297</i>&nbsp;                            // we do some heavy work like refreshes in the response so fork off to the generic threadpool
<i>298</i>&nbsp;                            return ThreadPool.Names.GENERIC;
<i>299</i>&nbsp;                        }
<i>300</i>&nbsp;
<i>301</i>&nbsp;                        @Override
<i>302</i>&nbsp;                        public RecoveryResponse read(StreamInput in) throws IOException {
<i>303</i>&nbsp;                            return new RecoveryResponse(in);
<i>304</i>&nbsp;                        }
<i>305</i>&nbsp;                    })
<i>306</i>&nbsp;            );
<b class="nc"><i>307</i>&nbsp;        } catch (CancellableThreads.ExecutionCancelledException e) {</b>
<b class="nc"><i>308</i>&nbsp;            logger.trace(&quot;recovery cancelled&quot;, e);</b>
<b class="nc"><i>309</i>&nbsp;        } catch (Exception e) {</b>
<b class="nc"><i>310</i>&nbsp;            handleException.accept(e);</b>
<b class="nc"><i>311</i>&nbsp;        }</b>
<b class="nc"><i>312</i>&nbsp;    }</b>
<i>313</i>&nbsp;
<i>314</i>&nbsp;    /**
<i>315</i>&nbsp;     * Prepare the start recovery request.
<i>316</i>&nbsp;     *
<i>317</i>&nbsp;     * @param logger         the logger
<i>318</i>&nbsp;     * @param localNode      the local node of the recovery target
<i>319</i>&nbsp;     * @param recoveryTarget the target of the recovery
<i>320</i>&nbsp;     * @param startingSeqNo  a sequence number that an operation-based peer recovery can start with.
<i>321</i>&nbsp;     *                       This is the first operation after the local checkpoint of the safe commit if exists.
<i>322</i>&nbsp;     * @return a start recovery request
<i>323</i>&nbsp;     */
<i>324</i>&nbsp;    public static StartRecoveryRequest getStartRecoveryRequest(Logger logger, DiscoveryNode localNode,
<i>325</i>&nbsp;                                                               RecoveryTarget recoveryTarget, long startingSeqNo) {
<i>326</i>&nbsp;        final StartRecoveryRequest request;
<b class="nc"><i>327</i>&nbsp;        logger.trace(&quot;{} collecting local files for [{}]&quot;, recoveryTarget.shardId(), recoveryTarget.sourceNode());</b>
<i>328</i>&nbsp;
<i>329</i>&nbsp;        Store.MetadataSnapshot metadataSnapshot;
<i>330</i>&nbsp;        try {
<b class="nc"><i>331</i>&nbsp;            metadataSnapshot = recoveryTarget.indexShard().snapshotStoreMetadata();</b>
<i>332</i>&nbsp;            // Make sure that the current translog is consistent with the Lucene index; otherwise, we have to throw away the Lucene index.
<i>333</i>&nbsp;            try {
<b class="nc"><i>334</i>&nbsp;                final String expectedTranslogUUID = metadataSnapshot.getCommitUserData().get(Translog.TRANSLOG_UUID_KEY);</b>
<b class="nc"><i>335</i>&nbsp;                final long globalCheckpoint = Translog.readGlobalCheckpoint(recoveryTarget.translogLocation(), expectedTranslogUUID);</b>
<b class="nc"><i>336</i>&nbsp;                assert globalCheckpoint + 1 &gt;= startingSeqNo : &quot;invalid startingSeqNo &quot; + startingSeqNo + &quot; &gt;= &quot; + globalCheckpoint;</b>
<b class="nc"><i>337</i>&nbsp;            } catch (IOException | TranslogCorruptedException e) {</b>
<b class="nc"><i>338</i>&nbsp;                logger.warn(new ParameterizedMessage(&quot;error while reading global checkpoint from translog, &quot; +</b>
<b class="nc"><i>339</i>&nbsp;                    &quot;resetting the starting sequence number from {} to unassigned and recovering as if there are none&quot;, startingSeqNo), e);</b>
<b class="nc"><i>340</i>&nbsp;                metadataSnapshot = Store.MetadataSnapshot.EMPTY;</b>
<b class="nc"><i>341</i>&nbsp;                startingSeqNo = UNASSIGNED_SEQ_NO;</b>
<b class="nc"><i>342</i>&nbsp;            }</b>
<b class="nc"><i>343</i>&nbsp;        } catch (final org.apache.lucene.index.IndexNotFoundException e) {</b>
<i>344</i>&nbsp;            // happens on an empty folder. no need to log
<b class="nc"><i>345</i>&nbsp;            assert startingSeqNo == UNASSIGNED_SEQ_NO : startingSeqNo;</b>
<b class="nc"><i>346</i>&nbsp;            logger.trace(&quot;{} shard folder empty, recovering all files&quot;, recoveryTarget);</b>
<b class="nc"><i>347</i>&nbsp;            metadataSnapshot = Store.MetadataSnapshot.EMPTY;</b>
<b class="nc"><i>348</i>&nbsp;        } catch (final IOException e) {</b>
<b class="nc"><i>349</i>&nbsp;            if (startingSeqNo != UNASSIGNED_SEQ_NO) {</b>
<b class="nc"><i>350</i>&nbsp;                logger.warn(new ParameterizedMessage(&quot;error while listing local files, resetting the starting sequence number from {} &quot; +</b>
<b class="nc"><i>351</i>&nbsp;                    &quot;to unassigned and recovering as if there are none&quot;, startingSeqNo), e);</b>
<b class="nc"><i>352</i>&nbsp;                startingSeqNo = UNASSIGNED_SEQ_NO;</b>
<i>353</i>&nbsp;            } else {
<b class="nc"><i>354</i>&nbsp;                logger.warn(&quot;error while listing local files, recovering as if there are none&quot;, e);</b>
<i>355</i>&nbsp;            }
<b class="nc"><i>356</i>&nbsp;            metadataSnapshot = Store.MetadataSnapshot.EMPTY;</b>
<b class="nc"><i>357</i>&nbsp;        }</b>
<b class="nc"><i>358</i>&nbsp;        logger.trace(&quot;{} local file count [{}]&quot;, recoveryTarget.shardId(), metadataSnapshot.size());</b>
<b class="nc"><i>359</i>&nbsp;        request = new StartRecoveryRequest(</b>
<b class="nc"><i>360</i>&nbsp;            recoveryTarget.shardId(),</b>
<b class="nc"><i>361</i>&nbsp;            recoveryTarget.indexShard().routingEntry().allocationId().getId(),</b>
<b class="nc"><i>362</i>&nbsp;            recoveryTarget.sourceNode(),</b>
<i>363</i>&nbsp;            localNode,
<i>364</i>&nbsp;            metadataSnapshot,
<b class="nc"><i>365</i>&nbsp;            recoveryTarget.state().getPrimary(),</b>
<b class="nc"><i>366</i>&nbsp;            recoveryTarget.recoveryId(),</b>
<i>367</i>&nbsp;            startingSeqNo);
<b class="nc"><i>368</i>&nbsp;        return request;</b>
<i>369</i>&nbsp;    }
<i>370</i>&nbsp;
<i>371</i>&nbsp;    public interface RecoveryListener {
<i>372</i>&nbsp;        void onRecoveryDone(RecoveryState state);
<i>373</i>&nbsp;
<i>374</i>&nbsp;        void onRecoveryFailure(RecoveryState state, RecoveryFailedException e, boolean sendShardFailure);
<i>375</i>&nbsp;    }
<i>376</i>&nbsp;
<b class="fc"><i>377</i>&nbsp;    class PrepareForTranslogOperationsRequestHandler implements TransportRequestHandler&lt;RecoveryPrepareForTranslogOperationsRequest&gt; {</b>
<i>378</i>&nbsp;
<i>379</i>&nbsp;        @Override
<i>380</i>&nbsp;        public void messageReceived(RecoveryPrepareForTranslogOperationsRequest request, TransportChannel channel, Task task) {
<b class="nc"><i>381</i>&nbsp;            try (RecoveryRef recoveryRef = onGoingRecoveries.getRecoverySafe(request.recoveryId(), request.shardId())) {</b>
<b class="nc"><i>382</i>&nbsp;                final ActionListener&lt;TransportResponse&gt; listener = new ChannelActionListener&lt;&gt;(channel, Actions.PREPARE_TRANSLOG, request);</b>
<b class="nc"><i>383</i>&nbsp;                recoveryRef.target().prepareForTranslogOperations(request.totalTranslogOps(),</b>
<b class="nc"><i>384</i>&nbsp;                    ActionListener.map(listener, nullVal -&gt; TransportResponse.Empty.INSTANCE));</b>
<b class="nc"><i>385</i>&nbsp;            }</b>
<b class="nc"><i>386</i>&nbsp;        }</b>
<i>387</i>&nbsp;    }
<i>388</i>&nbsp;
<b class="fc"><i>389</i>&nbsp;    class FinalizeRecoveryRequestHandler implements TransportRequestHandler&lt;RecoveryFinalizeRecoveryRequest&gt; {</b>
<i>390</i>&nbsp;
<i>391</i>&nbsp;        @Override
<i>392</i>&nbsp;        public void messageReceived(RecoveryFinalizeRecoveryRequest request, TransportChannel channel, Task task) throws Exception {
<b class="nc"><i>393</i>&nbsp;            try (RecoveryRef recoveryRef = onGoingRecoveries.getRecoverySafe(request.recoveryId(), request.shardId())) {</b>
<b class="nc"><i>394</i>&nbsp;                final ActionListener&lt;TransportResponse&gt; listener = new ChannelActionListener&lt;&gt;(channel, Actions.FINALIZE, request);</b>
<b class="nc"><i>395</i>&nbsp;                recoveryRef.target().finalizeRecovery(request.globalCheckpoint(), request.trimAboveSeqNo(),</b>
<b class="nc"><i>396</i>&nbsp;                    ActionListener.map(listener, nullVal -&gt; TransportResponse.Empty.INSTANCE));</b>
<b class="nc"><i>397</i>&nbsp;            }</b>
<b class="nc"><i>398</i>&nbsp;        }</b>
<i>399</i>&nbsp;    }
<i>400</i>&nbsp;
<b class="fc"><i>401</i>&nbsp;    class HandoffPrimaryContextRequestHandler implements TransportRequestHandler&lt;RecoveryHandoffPrimaryContextRequest&gt; {</b>
<i>402</i>&nbsp;
<i>403</i>&nbsp;        @Override
<i>404</i>&nbsp;        public void messageReceived(final RecoveryHandoffPrimaryContextRequest request, final TransportChannel channel,
<i>405</i>&nbsp;                                    Task task) throws Exception {
<b class="nc"><i>406</i>&nbsp;            try (RecoveryRef recoveryRef = onGoingRecoveries.getRecoverySafe(request.recoveryId(), request.shardId())) {</b>
<b class="nc"><i>407</i>&nbsp;                recoveryRef.target().handoffPrimaryContext(request.primaryContext());</b>
<b class="nc"><i>408</i>&nbsp;            }</b>
<b class="nc"><i>409</i>&nbsp;            channel.sendResponse(TransportResponse.Empty.INSTANCE);</b>
<b class="nc"><i>410</i>&nbsp;        }</b>
<i>411</i>&nbsp;
<i>412</i>&nbsp;    }
<i>413</i>&nbsp;
<b class="fc"><i>414</i>&nbsp;    class TranslogOperationsRequestHandler implements TransportRequestHandler&lt;RecoveryTranslogOperationsRequest&gt; {</b>
<i>415</i>&nbsp;
<i>416</i>&nbsp;        @Override
<i>417</i>&nbsp;        public void messageReceived(final RecoveryTranslogOperationsRequest request, final TransportChannel channel,
<i>418</i>&nbsp;                                    Task task) throws IOException {
<b class="nc"><i>419</i>&nbsp;            try (RecoveryRef recoveryRef =</b>
<b class="nc"><i>420</i>&nbsp;                     onGoingRecoveries.getRecoverySafe(request.recoveryId(), request.shardId())) {</b>
<b class="nc"><i>421</i>&nbsp;                final ClusterStateObserver observer = new ClusterStateObserver(clusterService, null, logger, threadPool.getThreadContext());</b>
<b class="nc"><i>422</i>&nbsp;                final RecoveryTarget recoveryTarget = recoveryRef.target();</b>
<b class="nc"><i>423</i>&nbsp;                final ActionListener&lt;RecoveryTranslogOperationsResponse&gt; listener =</b>
<i>424</i>&nbsp;                    new ChannelActionListener&lt;&gt;(channel, Actions.TRANSLOG_OPS, request);
<b class="nc"><i>425</i>&nbsp;                final Consumer&lt;Exception&gt; retryOnMappingException = exception -&gt; {</b>
<i>426</i>&nbsp;                    // in very rare cases a translog replay from primary is processed before a mapping update on this node
<i>427</i>&nbsp;                    // which causes local mapping changes since the mapping (clusterstate) might not have arrived on this node.
<b class="nc"><i>428</i>&nbsp;                    logger.debug(&quot;delaying recovery due to missing mapping changes&quot;, exception);</b>
<i>429</i>&nbsp;                    // we do not need to use a timeout here since the entire recovery mechanism has an inactivity protection (it will be
<i>430</i>&nbsp;                    // canceled)
<b class="nc"><i>431</i>&nbsp;                    observer.waitForNextChange(new ClusterStateObserver.Listener() {</b>
<i>432</i>&nbsp;                        @Override
<i>433</i>&nbsp;                        public void onNewClusterState(ClusterState state) {
<i>434</i>&nbsp;                            try {
<i>435</i>&nbsp;                                messageReceived(request, channel, task);
<i>436</i>&nbsp;                            } catch (Exception e) {
<i>437</i>&nbsp;                                listener.onFailure(e);
<i>438</i>&nbsp;                            }
<i>439</i>&nbsp;                        }
<i>440</i>&nbsp;
<i>441</i>&nbsp;                        @Override
<i>442</i>&nbsp;                        public void onClusterServiceClose() {
<i>443</i>&nbsp;                            listener.onFailure(new ElasticsearchException(
<i>444</i>&nbsp;                                &quot;cluster service was closed while waiting for mapping updates&quot;));
<i>445</i>&nbsp;                        }
<i>446</i>&nbsp;
<i>447</i>&nbsp;                        @Override
<i>448</i>&nbsp;                        public void onTimeout(TimeValue timeout) {
<i>449</i>&nbsp;                            // note that we do not use a timeout (see comment above)
<i>450</i>&nbsp;                            listener.onFailure(new ElasticsearchTimeoutException(&quot;timed out waiting for mapping updates &quot; +
<i>451</i>&nbsp;                                &quot;(timeout [&quot; + timeout + &quot;])&quot;));
<i>452</i>&nbsp;                        }
<i>453</i>&nbsp;                    });
<b class="nc"><i>454</i>&nbsp;                };</b>
<b class="nc"><i>455</i>&nbsp;                final IndexMetaData indexMetaData = clusterService.state().metaData().index(request.shardId().getIndex());</b>
<b class="nc"><i>456</i>&nbsp;                final long mappingVersionOnTarget = indexMetaData != null ? indexMetaData.getMappingVersion() : 0L;</b>
<b class="nc"><i>457</i>&nbsp;                recoveryTarget.indexTranslogOperations(</b>
<b class="nc"><i>458</i>&nbsp;                        request.operations(),</b>
<b class="nc"><i>459</i>&nbsp;                        request.totalTranslogOps(),</b>
<b class="nc"><i>460</i>&nbsp;                        request.maxSeenAutoIdTimestampOnPrimary(),</b>
<b class="nc"><i>461</i>&nbsp;                        request.maxSeqNoOfUpdatesOrDeletesOnPrimary(),</b>
<b class="nc"><i>462</i>&nbsp;                        request.retentionLeases(),</b>
<b class="nc"><i>463</i>&nbsp;                        request.mappingVersionOnPrimary(),</b>
<b class="nc"><i>464</i>&nbsp;                        ActionListener.wrap(</b>
<b class="nc"><i>465</i>&nbsp;                                checkpoint -&gt; listener.onResponse(new RecoveryTranslogOperationsResponse(checkpoint)),</b>
<i>466</i>&nbsp;                                e -&gt; {
<i>467</i>&nbsp;                                    // do not retry if the mapping on replica is at least as recent as the mapping
<i>468</i>&nbsp;                                    // that the primary used to index the operations in the request.
<b class="nc"><i>469</i>&nbsp;                                    if (mappingVersionOnTarget &lt; request.mappingVersionOnPrimary() &amp;&amp; e instanceof MapperException) {</b>
<b class="nc"><i>470</i>&nbsp;                                        retryOnMappingException.accept(e);</b>
<i>471</i>&nbsp;                                    } else {
<b class="nc"><i>472</i>&nbsp;                                        listener.onFailure(e);</b>
<i>473</i>&nbsp;                                    }
<b class="nc"><i>474</i>&nbsp;                                })</b>
<i>475</i>&nbsp;                );
<b class="nc"><i>476</i>&nbsp;            }</b>
<b class="nc"><i>477</i>&nbsp;        }</b>
<i>478</i>&nbsp;    }
<i>479</i>&nbsp;
<b class="fc"><i>480</i>&nbsp;    class FilesInfoRequestHandler implements TransportRequestHandler&lt;RecoveryFilesInfoRequest&gt; {</b>
<i>481</i>&nbsp;
<i>482</i>&nbsp;        @Override
<i>483</i>&nbsp;        public void messageReceived(RecoveryFilesInfoRequest request, TransportChannel channel, Task task) throws Exception {
<b class="nc"><i>484</i>&nbsp;            try (RecoveryRef recoveryRef = onGoingRecoveries.getRecoverySafe(request.recoveryId(), request.shardId())) {</b>
<b class="nc"><i>485</i>&nbsp;                final ActionListener&lt;TransportResponse&gt; listener = new ChannelActionListener&lt;&gt;(channel, Actions.FILES_INFO, request);</b>
<b class="nc"><i>486</i>&nbsp;                recoveryRef.target().receiveFileInfo(</b>
<i>487</i>&nbsp;                    request.phase1FileNames, request.phase1FileSizes, request.phase1ExistingFileNames, request.phase1ExistingFileSizes,
<b class="nc"><i>488</i>&nbsp;                    request.totalTranslogOps, ActionListener.map(listener, nullVal -&gt; TransportResponse.Empty.INSTANCE));</b>
<b class="nc"><i>489</i>&nbsp;            }</b>
<b class="nc"><i>490</i>&nbsp;        }</b>
<i>491</i>&nbsp;    }
<i>492</i>&nbsp;
<b class="fc"><i>493</i>&nbsp;    class CleanFilesRequestHandler implements TransportRequestHandler&lt;RecoveryCleanFilesRequest&gt; {</b>
<i>494</i>&nbsp;
<i>495</i>&nbsp;        @Override
<i>496</i>&nbsp;        public void messageReceived(RecoveryCleanFilesRequest request, TransportChannel channel, Task task) throws Exception {
<b class="nc"><i>497</i>&nbsp;            try (RecoveryRef recoveryRef = onGoingRecoveries.getRecoverySafe(request.recoveryId(), request.shardId())) {</b>
<b class="nc"><i>498</i>&nbsp;                final ActionListener&lt;TransportResponse&gt; listener = new ChannelActionListener&lt;&gt;(channel, Actions.CLEAN_FILES, request);</b>
<b class="nc"><i>499</i>&nbsp;                recoveryRef.target().cleanFiles(request.totalTranslogOps(), request.getGlobalCheckpoint(), request.sourceMetaSnapshot(),</b>
<b class="nc"><i>500</i>&nbsp;                    ActionListener.map(listener, nullVal -&gt; TransportResponse.Empty.INSTANCE));</b>
<b class="nc"><i>501</i>&nbsp;            }</b>
<b class="nc"><i>502</i>&nbsp;        }</b>
<i>503</i>&nbsp;    }
<i>504</i>&nbsp;
<b class="fc"><i>505</i>&nbsp;    class FileChunkTransportRequestHandler implements TransportRequestHandler&lt;RecoveryFileChunkRequest&gt; {</b>
<i>506</i>&nbsp;
<i>507</i>&nbsp;        // How many bytes we&#39;ve copied since we last called RateLimiter.pause
<b class="fc"><i>508</i>&nbsp;        final AtomicLong bytesSinceLastPause = new AtomicLong();</b>
<i>509</i>&nbsp;
<i>510</i>&nbsp;        @Override
<i>511</i>&nbsp;        public void messageReceived(final RecoveryFileChunkRequest request, TransportChannel channel, Task task) throws Exception {
<b class="nc"><i>512</i>&nbsp;            try (RecoveryRef recoveryRef = onGoingRecoveries.getRecoverySafe(request.recoveryId(), request.shardId())) {</b>
<b class="nc"><i>513</i>&nbsp;                final RecoveryTarget recoveryTarget = recoveryRef.target();</b>
<b class="nc"><i>514</i>&nbsp;                final RecoveryState.Index indexState = recoveryTarget.state().getIndex();</b>
<b class="nc"><i>515</i>&nbsp;                if (request.sourceThrottleTimeInNanos() != RecoveryState.Index.UNKNOWN) {</b>
<b class="nc"><i>516</i>&nbsp;                    indexState.addSourceThrottling(request.sourceThrottleTimeInNanos());</b>
<i>517</i>&nbsp;                }
<i>518</i>&nbsp;
<b class="nc"><i>519</i>&nbsp;                RateLimiter rateLimiter = recoverySettings.rateLimiter();</b>
<b class="nc"><i>520</i>&nbsp;                if (rateLimiter != null) {</b>
<b class="nc"><i>521</i>&nbsp;                    long bytes = bytesSinceLastPause.addAndGet(request.content().length());</b>
<b class="nc"><i>522</i>&nbsp;                    if (bytes &gt; rateLimiter.getMinPauseCheckBytes()) {</b>
<i>523</i>&nbsp;                        // Time to pause
<b class="nc"><i>524</i>&nbsp;                        bytesSinceLastPause.addAndGet(-bytes);</b>
<b class="nc"><i>525</i>&nbsp;                        long throttleTimeInNanos = rateLimiter.pause(bytes);</b>
<b class="nc"><i>526</i>&nbsp;                        indexState.addTargetThrottling(throttleTimeInNanos);</b>
<b class="nc"><i>527</i>&nbsp;                        recoveryTarget.indexShard().recoveryStats().addThrottleTime(throttleTimeInNanos);</b>
<i>528</i>&nbsp;                    }
<i>529</i>&nbsp;                }
<b class="nc"><i>530</i>&nbsp;                final ActionListener&lt;TransportResponse&gt; listener = new ChannelActionListener&lt;&gt;(channel, Actions.FILE_CHUNK, request);</b>
<b class="nc"><i>531</i>&nbsp;                recoveryTarget.writeFileChunk(request.metadata(), request.position(), request.content(), request.lastChunk(),</b>
<b class="nc"><i>532</i>&nbsp;                    request.totalTranslogOps(), ActionListener.map(listener, nullVal -&gt; TransportResponse.Empty.INSTANCE));</b>
<b class="nc"><i>533</i>&nbsp;            }</b>
<b class="nc"><i>534</i>&nbsp;        }</b>
<i>535</i>&nbsp;    }
<i>536</i>&nbsp;
<i>537</i>&nbsp;    class RecoveryRunner extends AbstractRunnable {
<i>538</i>&nbsp;
<i>539</i>&nbsp;        final long recoveryId;
<i>540</i>&nbsp;
<i>541</i>&nbsp;        RecoveryRunner(long recoveryId) {
<i>542</i>&nbsp;            this.recoveryId = recoveryId;
<i>543</i>&nbsp;        }
<i>544</i>&nbsp;
<i>545</i>&nbsp;        @Override
<i>546</i>&nbsp;        public void onFailure(Exception e) {
<i>547</i>&nbsp;            try (RecoveryRef recoveryRef = onGoingRecoveries.getRecovery(recoveryId)) {
<i>548</i>&nbsp;                if (recoveryRef != null) {
<i>549</i>&nbsp;                    logger.error(() -&gt; new ParameterizedMessage(&quot;unexpected error during recovery [{}], failing shard&quot;, recoveryId), e);
<i>550</i>&nbsp;                    onGoingRecoveries.failRecovery(recoveryId,
<i>551</i>&nbsp;                            new RecoveryFailedException(recoveryRef.target().state(), &quot;unexpected error&quot;, e),
<i>552</i>&nbsp;                            true // be safe
<i>553</i>&nbsp;                    );
<i>554</i>&nbsp;                } else {
<i>555</i>&nbsp;                    logger.debug(() -&gt; new ParameterizedMessage(
<i>556</i>&nbsp;                            &quot;unexpected error during recovery, but recovery id [{}] is finished&quot;, recoveryId), e);
<i>557</i>&nbsp;                }
<i>558</i>&nbsp;            }
<i>559</i>&nbsp;        }
<i>560</i>&nbsp;
<i>561</i>&nbsp;        @Override
<i>562</i>&nbsp;        public void doRun() {
<i>563</i>&nbsp;            doRecovery(recoveryId);
<i>564</i>&nbsp;        }
<i>565</i>&nbsp;    }
<i>566</i>&nbsp;}
</div>
</div>

<div class="footer">
    
    <div style="float:right;">generated on 2020-02-09 18:46</div>
</div>
</body>
</html>
