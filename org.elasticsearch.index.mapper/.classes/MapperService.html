


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html id="htmlId">
<head>
  <title>Coverage Report :: MapperService</title>
  <style type="text/css">
    @import "../../.css/coverage.css";
  </style>
</head>

<body>
<div class="header"></div>

<div class="content">
<div class="breadCrumbs">
    [ <a href="../../index.html">all classes</a> ]
    [ <a href="../index.html">org.elasticsearch.index.mapper</a> ]
</div>

<h1>Coverage Summary for Class: MapperService (org.elasticsearch.index.mapper)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">MapperService</td>
<td class="coverageStat">
  <span class="percent">
    67.4%
  </span>
  <span class="absValue">
    (31/ 46)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    56.7%
  </span>
  <span class="absValue">
    (204/ 360)
  </span>
</td>
</tr>
  <tr>
    <td class="name">MapperService$MapperAnalyzerWrapper</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    45.5%
  </span>
  <span class="absValue">
    (5/ 11)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MapperService$MergeReason</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/ 3)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>total</strong></td>
<td class="coverageStat">
  <span class="percent">
    68%
  </span>
  <span class="absValue">
    (34/ 50)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    56.7%
  </span>
  <span class="absValue">
    (212/ 374)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<div class="sourceCode"><i>1</i>&nbsp;/*
<i>2</i>&nbsp; * Licensed to Elasticsearch under one or more contributor
<i>3</i>&nbsp; * license agreements. See the NOTICE file distributed with
<i>4</i>&nbsp; * this work for additional information regarding copyright
<i>5</i>&nbsp; * ownership. Elasticsearch licenses this file to you under
<i>6</i>&nbsp; * the Apache License, Version 2.0 (the &quot;License&quot;); you may
<i>7</i>&nbsp; * not use this file except in compliance with the License.
<i>8</i>&nbsp; * You may obtain a copy of the License at
<i>9</i>&nbsp; *
<i>10</i>&nbsp; *    http://www.apache.org/licenses/LICENSE-2.0
<i>11</i>&nbsp; *
<i>12</i>&nbsp; * Unless required by applicable law or agreed to in writing,
<i>13</i>&nbsp; * software distributed under the License is distributed on an
<i>14</i>&nbsp; * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
<i>15</i>&nbsp; * KIND, either express or implied.  See the License for the
<i>16</i>&nbsp; * specific language governing permissions and limitations
<i>17</i>&nbsp; * under the License.
<i>18</i>&nbsp; */
<i>19</i>&nbsp;
<i>20</i>&nbsp;package org.elasticsearch.index.mapper;
<i>21</i>&nbsp;
<i>22</i>&nbsp;import com.carrotsearch.hppc.ObjectHashSet;
<i>23</i>&nbsp;import com.carrotsearch.hppc.cursors.ObjectCursor;
<i>24</i>&nbsp;import org.apache.logging.log4j.LogManager;
<i>25</i>&nbsp;import org.apache.logging.log4j.message.ParameterizedMessage;
<i>26</i>&nbsp;import org.apache.lucene.analysis.Analyzer;
<i>27</i>&nbsp;import org.apache.lucene.analysis.DelegatingAnalyzerWrapper;
<i>28</i>&nbsp;import org.elasticsearch.Assertions;
<i>29</i>&nbsp;import org.elasticsearch.Version;
<i>30</i>&nbsp;import org.elasticsearch.cluster.metadata.IndexMetaData;
<i>31</i>&nbsp;import org.elasticsearch.cluster.metadata.MappingMetaData;
<i>32</i>&nbsp;import org.elasticsearch.common.Nullable;
<i>33</i>&nbsp;import org.elasticsearch.common.Strings;
<i>34</i>&nbsp;import org.elasticsearch.common.compress.CompressedXContent;
<i>35</i>&nbsp;import org.elasticsearch.common.logging.DeprecationLogger;
<i>36</i>&nbsp;import org.elasticsearch.common.regex.Regex;
<i>37</i>&nbsp;import org.elasticsearch.common.settings.Setting;
<i>38</i>&nbsp;import org.elasticsearch.common.settings.Setting.Property;
<i>39</i>&nbsp;import org.elasticsearch.common.settings.Settings;
<i>40</i>&nbsp;import org.elasticsearch.common.xcontent.LoggingDeprecationHandler;
<i>41</i>&nbsp;import org.elasticsearch.common.xcontent.NamedXContentRegistry;
<i>42</i>&nbsp;import org.elasticsearch.common.xcontent.XContentFactory;
<i>43</i>&nbsp;import org.elasticsearch.common.xcontent.XContentHelper;
<i>44</i>&nbsp;import org.elasticsearch.common.xcontent.XContentParser;
<i>45</i>&nbsp;import org.elasticsearch.common.xcontent.XContentType;
<i>46</i>&nbsp;import org.elasticsearch.index.AbstractIndexComponent;
<i>47</i>&nbsp;import org.elasticsearch.index.IndexSettings;
<i>48</i>&nbsp;import org.elasticsearch.index.IndexSortConfig;
<i>49</i>&nbsp;import org.elasticsearch.index.analysis.AnalysisRegistry;
<i>50</i>&nbsp;import org.elasticsearch.index.analysis.CharFilterFactory;
<i>51</i>&nbsp;import org.elasticsearch.index.analysis.IndexAnalyzers;
<i>52</i>&nbsp;import org.elasticsearch.index.analysis.NamedAnalyzer;
<i>53</i>&nbsp;import org.elasticsearch.index.analysis.ReloadableCustomAnalyzer;
<i>54</i>&nbsp;import org.elasticsearch.index.analysis.TokenFilterFactory;
<i>55</i>&nbsp;import org.elasticsearch.index.analysis.TokenizerFactory;
<i>56</i>&nbsp;import org.elasticsearch.index.mapper.Mapper.BuilderContext;
<i>57</i>&nbsp;import org.elasticsearch.index.query.QueryShardContext;
<i>58</i>&nbsp;import org.elasticsearch.index.similarity.SimilarityService;
<i>59</i>&nbsp;import org.elasticsearch.indices.InvalidTypeNameException;
<i>60</i>&nbsp;import org.elasticsearch.indices.mapper.MapperRegistry;
<i>61</i>&nbsp;import org.elasticsearch.search.suggest.completion.context.ContextMapping;
<i>62</i>&nbsp;
<i>63</i>&nbsp;import java.io.Closeable;
<i>64</i>&nbsp;import java.io.IOException;
<i>65</i>&nbsp;import java.util.ArrayList;
<i>66</i>&nbsp;import java.util.Arrays;
<i>67</i>&nbsp;import java.util.Collection;
<i>68</i>&nbsp;import java.util.Collections;
<i>69</i>&nbsp;import java.util.HashMap;
<i>70</i>&nbsp;import java.util.HashSet;
<i>71</i>&nbsp;import java.util.LinkedHashMap;
<i>72</i>&nbsp;import java.util.List;
<i>73</i>&nbsp;import java.util.Map;
<i>74</i>&nbsp;import java.util.Set;
<i>75</i>&nbsp;import java.util.function.Function;
<i>76</i>&nbsp;import java.util.function.Supplier;
<i>77</i>&nbsp;import java.util.stream.Stream;
<i>78</i>&nbsp;
<i>79</i>&nbsp;import static java.util.Collections.emptyMap;
<i>80</i>&nbsp;import static java.util.Collections.unmodifiableMap;
<i>81</i>&nbsp;
<b class="fc"><i>82</i>&nbsp;public class MapperService extends AbstractIndexComponent implements Closeable {</b>
<i>83</i>&nbsp;
<i>84</i>&nbsp;    /**
<i>85</i>&nbsp;     * The reason why a mapping is being merged.
<i>86</i>&nbsp;     */
<b class="fc"><i>87</i>&nbsp;    public enum MergeReason {</b>
<i>88</i>&nbsp;        /**
<i>89</i>&nbsp;         * Create or update a mapping.
<i>90</i>&nbsp;         */
<b class="fc"><i>91</i>&nbsp;        MAPPING_UPDATE,</b>
<i>92</i>&nbsp;        /**
<i>93</i>&nbsp;         * Recovery of an existing mapping, for instance because of a restart,
<i>94</i>&nbsp;         * if a shard was moved to a different node or for administrative
<i>95</i>&nbsp;         * purposes.
<i>96</i>&nbsp;         */
<b class="fc"><i>97</i>&nbsp;        MAPPING_RECOVERY;</b>
<i>98</i>&nbsp;    }
<i>99</i>&nbsp;
<i>100</i>&nbsp;    public static final String DEFAULT_MAPPING = &quot;_default_&quot;;
<i>101</i>&nbsp;    public static final String SINGLE_MAPPING_NAME = &quot;_doc&quot;;
<b class="fc"><i>102</i>&nbsp;    public static final Setting&lt;Long&gt; INDEX_MAPPING_NESTED_FIELDS_LIMIT_SETTING =</b>
<b class="fc"><i>103</i>&nbsp;        Setting.longSetting(&quot;index.mapping.nested_fields.limit&quot;, 50L, 0, Property.Dynamic, Property.IndexScope);</b>
<i>104</i>&nbsp;    // maximum allowed number of nested json objects across all fields in a single document
<b class="fc"><i>105</i>&nbsp;    public static final Setting&lt;Long&gt; INDEX_MAPPING_NESTED_DOCS_LIMIT_SETTING =</b>
<b class="fc"><i>106</i>&nbsp;        Setting.longSetting(&quot;index.mapping.nested_objects.limit&quot;, 10000L, 0, Property.Dynamic, Property.IndexScope);</b>
<b class="fc"><i>107</i>&nbsp;    public static final Setting&lt;Long&gt; INDEX_MAPPING_TOTAL_FIELDS_LIMIT_SETTING =</b>
<b class="fc"><i>108</i>&nbsp;        Setting.longSetting(&quot;index.mapping.total_fields.limit&quot;, 1000L, 0, Property.Dynamic, Property.IndexScope);</b>
<b class="fc"><i>109</i>&nbsp;    public static final Setting&lt;Long&gt; INDEX_MAPPING_DEPTH_LIMIT_SETTING =</b>
<b class="fc"><i>110</i>&nbsp;        Setting.longSetting(&quot;index.mapping.depth.limit&quot;, 20L, 1, Property.Dynamic, Property.IndexScope);</b>
<b class="fc"><i>111</i>&nbsp;    public static final Setting&lt;Long&gt; INDEX_MAPPING_FIELD_NAME_LENGTH_LIMIT_SETTING =</b>
<b class="fc"><i>112</i>&nbsp;        Setting.longSetting(&quot;index.mapping.field_name_length.limit&quot;, Long.MAX_VALUE, 1L, Property.Dynamic, Property.IndexScope);</b>
<i>113</i>&nbsp;    public static final boolean INDEX_MAPPER_DYNAMIC_DEFAULT = true;
<i>114</i>&nbsp;    @Deprecated
<b class="fc"><i>115</i>&nbsp;    public static final Setting&lt;Boolean&gt; INDEX_MAPPER_DYNAMIC_SETTING =</b>
<b class="fc"><i>116</i>&nbsp;        Setting.boolSetting(&quot;index.mapper.dynamic&quot;, INDEX_MAPPER_DYNAMIC_DEFAULT,</b>
<i>117</i>&nbsp;                Property.Dynamic, Property.IndexScope, Property.Deprecated);
<i>118</i>&nbsp;
<i>119</i>&nbsp;    //TODO this needs to be cleaned up: _timestamp and _ttl are not supported anymore, _field_names, _seq_no, _version and _source are
<i>120</i>&nbsp;    //also missing, not sure if on purpose. See IndicesModule#getMetadataMappers
<b class="fc"><i>121</i>&nbsp;    private static final String[] SORTED_META_FIELDS = new String[]{</b>
<i>122</i>&nbsp;        &quot;_id&quot;, IgnoredFieldMapper.NAME, &quot;_index&quot;, &quot;_routing&quot;, &quot;_size&quot;, &quot;_timestamp&quot;, &quot;_ttl&quot;, &quot;_type&quot;
<i>123</i>&nbsp;    };
<i>124</i>&nbsp;
<b class="fc"><i>125</i>&nbsp;    private static final ObjectHashSet&lt;String&gt; META_FIELDS = ObjectHashSet.from(SORTED_META_FIELDS);</b>
<i>126</i>&nbsp;
<b class="fc"><i>127</i>&nbsp;    private static final DeprecationLogger deprecationLogger = new DeprecationLogger(LogManager.getLogger(MapperService.class));</b>
<i>128</i>&nbsp;
<i>129</i>&nbsp;    private final IndexAnalyzers indexAnalyzers;
<i>130</i>&nbsp;
<i>131</i>&nbsp;    private volatile String defaultMappingSource;
<i>132</i>&nbsp;
<i>133</i>&nbsp;    private volatile DocumentMapper mapper;
<i>134</i>&nbsp;    private volatile DocumentMapper defaultMapper;
<i>135</i>&nbsp;
<i>136</i>&nbsp;    private volatile FieldTypeLookup fieldTypes;
<b class="fc"><i>137</i>&nbsp;    private volatile Map&lt;String, ObjectMapper&gt; fullPathObjectMappers = emptyMap();</b>
<b class="fc"><i>138</i>&nbsp;    private boolean hasNested = false; // updated dynamically to true when a nested object is added</b>
<i>139</i>&nbsp;
<i>140</i>&nbsp;    private final DocumentMapperParser documentParser;
<i>141</i>&nbsp;
<i>142</i>&nbsp;    private final MapperAnalyzerWrapper indexAnalyzer;
<i>143</i>&nbsp;    private final MapperAnalyzerWrapper searchAnalyzer;
<i>144</i>&nbsp;    private final MapperAnalyzerWrapper searchQuoteAnalyzer;
<i>145</i>&nbsp;
<b class="fc"><i>146</i>&nbsp;    private volatile Map&lt;String, MappedFieldType&gt; unmappedFieldTypes = emptyMap();</b>
<i>147</i>&nbsp;
<i>148</i>&nbsp;    final MapperRegistry mapperRegistry;
<i>149</i>&nbsp;
<i>150</i>&nbsp;    public MapperService(IndexSettings indexSettings, IndexAnalyzers indexAnalyzers, NamedXContentRegistry xContentRegistry,
<i>151</i>&nbsp;                         SimilarityService similarityService, MapperRegistry mapperRegistry,
<i>152</i>&nbsp;                         Supplier&lt;QueryShardContext&gt; queryShardContextSupplier) {
<b class="fc"><i>153</i>&nbsp;        super(indexSettings);</b>
<b class="fc"><i>154</i>&nbsp;        this.indexAnalyzers = indexAnalyzers;</b>
<b class="fc"><i>155</i>&nbsp;        this.fieldTypes = new FieldTypeLookup();</b>
<b class="fc"><i>156</i>&nbsp;        this.documentParser = new DocumentMapperParser(indexSettings, this, xContentRegistry, similarityService, mapperRegistry,</b>
<i>157</i>&nbsp;                queryShardContextSupplier);
<b class="fc"><i>158</i>&nbsp;        this.indexAnalyzer = new MapperAnalyzerWrapper(indexAnalyzers.getDefaultIndexAnalyzer(), p -&gt; p.indexAnalyzer());</b>
<b class="fc"><i>159</i>&nbsp;        this.searchAnalyzer = new MapperAnalyzerWrapper(indexAnalyzers.getDefaultSearchAnalyzer(), p -&gt; p.searchAnalyzer());</b>
<b class="fc"><i>160</i>&nbsp;        this.searchQuoteAnalyzer = new MapperAnalyzerWrapper(indexAnalyzers.getDefaultSearchQuoteAnalyzer(), p -&gt; p.searchQuoteAnalyzer());</b>
<b class="fc"><i>161</i>&nbsp;        this.mapperRegistry = mapperRegistry;</b>
<i>162</i>&nbsp;
<b class="fc"><i>163</i>&nbsp;        if (INDEX_MAPPER_DYNAMIC_SETTING.exists(indexSettings.getSettings()) &amp;&amp;</b>
<b class="nc"><i>164</i>&nbsp;                indexSettings.getIndexVersionCreated().onOrAfter(Version.V_7_0_0)) {</b>
<b class="nc"><i>165</i>&nbsp;            throw new IllegalArgumentException(&quot;Setting &quot; + INDEX_MAPPER_DYNAMIC_SETTING.getKey() + &quot; was removed after version 6.0.0&quot;);</b>
<i>166</i>&nbsp;        }
<i>167</i>&nbsp;
<b class="fc"><i>168</i>&nbsp;        defaultMappingSource = &quot;{\&quot;_default_\&quot;:{}}&quot;;</b>
<i>169</i>&nbsp;
<b class="fc"><i>170</i>&nbsp;        if (logger.isTraceEnabled()) {</b>
<b class="nc"><i>171</i>&nbsp;            logger.trace(&quot;default mapping source[{}]&quot;, defaultMappingSource);</b>
<i>172</i>&nbsp;        }
<b class="fc"><i>173</i>&nbsp;    }</b>
<i>174</i>&nbsp;
<i>175</i>&nbsp;    public boolean hasNested() {
<b class="nc"><i>176</i>&nbsp;        return this.hasNested;</b>
<i>177</i>&nbsp;    }
<i>178</i>&nbsp;
<i>179</i>&nbsp;    public IndexAnalyzers getIndexAnalyzers() {
<b class="fc"><i>180</i>&nbsp;        return this.indexAnalyzers;</b>
<i>181</i>&nbsp;    }
<i>182</i>&nbsp;
<i>183</i>&nbsp;    public NamedAnalyzer getNamedAnalyzer(String analyzerName) {
<b class="nc"><i>184</i>&nbsp;        return this.indexAnalyzers.get(analyzerName);</b>
<i>185</i>&nbsp;    }
<i>186</i>&nbsp;
<i>187</i>&nbsp;    public DocumentMapperParser documentMapperParser() {
<b class="fc"><i>188</i>&nbsp;        return this.documentParser;</b>
<i>189</i>&nbsp;    }
<i>190</i>&nbsp;
<i>191</i>&nbsp;    /**
<i>192</i>&nbsp;     * Parses the mappings (formatted as JSON) into a map
<i>193</i>&nbsp;     */
<i>194</i>&nbsp;    public static Map&lt;String, Object&gt; parseMapping(NamedXContentRegistry xContentRegistry, String mappingSource) throws Exception {
<b class="nc"><i>195</i>&nbsp;        try (XContentParser parser = XContentType.JSON.xContent()</b>
<b class="nc"><i>196</i>&nbsp;                .createParser(xContentRegistry, LoggingDeprecationHandler.INSTANCE, mappingSource)) {</b>
<b class="nc"><i>197</i>&nbsp;            return parser.map();</b>
<b class="nc"><i>198</i>&nbsp;        }</b>
<i>199</i>&nbsp;    }
<i>200</i>&nbsp;
<i>201</i>&nbsp;    /**
<i>202</i>&nbsp;     * Update mapping by only merging the metadata that is different between received and stored entries
<i>203</i>&nbsp;     */
<i>204</i>&nbsp;    public boolean updateMapping(final IndexMetaData currentIndexMetaData, final IndexMetaData newIndexMetaData) throws IOException {
<b class="fc"><i>205</i>&nbsp;        assert newIndexMetaData.getIndex().equals(index()) : &quot;index mismatch: expected &quot; + index()</b>
<b class="nc"><i>206</i>&nbsp;            + &quot; but was &quot; + newIndexMetaData.getIndex();</b>
<i>207</i>&nbsp;        // go over and add the relevant mappings (or update them)
<b class="fc"><i>208</i>&nbsp;        Set&lt;String&gt; existingMappers = new HashSet&lt;&gt;();</b>
<b class="fc"><i>209</i>&nbsp;        if (mapper != null) {</b>
<b class="nc"><i>210</i>&nbsp;            existingMappers.add(mapper.type());</b>
<i>211</i>&nbsp;        }
<b class="fc"><i>212</i>&nbsp;        if (defaultMapper != null) {</b>
<b class="nc"><i>213</i>&nbsp;            existingMappers.add(DEFAULT_MAPPING);</b>
<i>214</i>&nbsp;        }
<i>215</i>&nbsp;        final Map&lt;String, DocumentMapper&gt; updatedEntries;
<i>216</i>&nbsp;        try {
<i>217</i>&nbsp;            // only update entries if needed
<b class="fc"><i>218</i>&nbsp;            updatedEntries = internalMerge(newIndexMetaData, MergeReason.MAPPING_RECOVERY, true);</b>
<b class="nc"><i>219</i>&nbsp;        } catch (Exception e) {</b>
<b class="nc"><i>220</i>&nbsp;            logger.warn(() -&gt; new ParameterizedMessage(&quot;[{}] failed to apply mappings&quot;, index()), e);</b>
<b class="nc"><i>221</i>&nbsp;            throw e;</b>
<b class="fc"><i>222</i>&nbsp;        }</b>
<i>223</i>&nbsp;
<b class="fc"><i>224</i>&nbsp;        boolean requireRefresh = false;</b>
<i>225</i>&nbsp;
<b class="fc"><i>226</i>&nbsp;        assertMappingVersion(currentIndexMetaData, newIndexMetaData, updatedEntries);</b>
<i>227</i>&nbsp;
<b class="fc"><i>228</i>&nbsp;        for (DocumentMapper documentMapper : updatedEntries.values()) {</b>
<b class="nc"><i>229</i>&nbsp;            String mappingType = documentMapper.type();</b>
<i>230</i>&nbsp;            MappingMetaData mappingMetaData;
<b class="nc"><i>231</i>&nbsp;            if (mappingType.equals(MapperService.DEFAULT_MAPPING)) {</b>
<b class="nc"><i>232</i>&nbsp;                mappingMetaData = newIndexMetaData.defaultMapping();</b>
<i>233</i>&nbsp;            } else {
<b class="nc"><i>234</i>&nbsp;                mappingMetaData = newIndexMetaData.mapping();</b>
<b class="nc"><i>235</i>&nbsp;                assert mappingType.equals(mappingMetaData.type());</b>
<i>236</i>&nbsp;            }
<b class="nc"><i>237</i>&nbsp;            CompressedXContent incomingMappingSource = mappingMetaData.source();</b>
<i>238</i>&nbsp;
<b class="nc"><i>239</i>&nbsp;            String op = existingMappers.contains(mappingType) ? &quot;updated&quot; : &quot;added&quot;;</b>
<b class="nc"><i>240</i>&nbsp;            if (logger.isDebugEnabled() &amp;&amp; incomingMappingSource.compressed().length &lt; 512) {</b>
<b class="nc"><i>241</i>&nbsp;                logger.debug(&quot;[{}] {} mapping [{}], source [{}]&quot;, index(), op, mappingType, incomingMappingSource.string());</b>
<b class="nc"><i>242</i>&nbsp;            } else if (logger.isTraceEnabled()) {</b>
<b class="nc"><i>243</i>&nbsp;                logger.trace(&quot;[{}] {} mapping [{}], source [{}]&quot;, index(), op, mappingType, incomingMappingSource.string());</b>
<i>244</i>&nbsp;            } else {
<b class="nc"><i>245</i>&nbsp;                logger.debug(&quot;[{}] {} mapping [{}] (source suppressed due to length, use TRACE level if needed)&quot;,</b>
<b class="nc"><i>246</i>&nbsp;                    index(), op, mappingType);</b>
<i>247</i>&nbsp;            }
<i>248</i>&nbsp;
<i>249</i>&nbsp;            // refresh mapping can happen when the parsing/merging of the mapping from the metadata doesn&#39;t result in the same
<i>250</i>&nbsp;            // mapping, in this case, we send to the master to refresh its own version of the mappings (to conform with the
<i>251</i>&nbsp;            // merge version of it, which it does when refreshing the mappings), and warn log it.
<b class="nc"><i>252</i>&nbsp;            if (documentMapper(mappingType).mappingSource().equals(incomingMappingSource) == false) {</b>
<b class="nc"><i>253</i>&nbsp;                logger.debug(&quot;[{}] parsed mapping [{}], and got different sources\noriginal:\n{}\nparsed:\n{}&quot;,</b>
<b class="nc"><i>254</i>&nbsp;                    index(), mappingType, incomingMappingSource, documentMapper(mappingType).mappingSource());</b>
<i>255</i>&nbsp;
<b class="nc"><i>256</i>&nbsp;                requireRefresh = true;</b>
<i>257</i>&nbsp;            }
<b class="nc"><i>258</i>&nbsp;        }</b>
<i>259</i>&nbsp;
<b class="fc"><i>260</i>&nbsp;        return requireRefresh;</b>
<i>261</i>&nbsp;    }
<i>262</i>&nbsp;
<i>263</i>&nbsp;    private void assertMappingVersion(
<i>264</i>&nbsp;            final IndexMetaData currentIndexMetaData,
<i>265</i>&nbsp;            final IndexMetaData newIndexMetaData,
<i>266</i>&nbsp;            final Map&lt;String, DocumentMapper&gt; updatedEntries) {
<b class="fc"><i>267</i>&nbsp;        if (Assertions.ENABLED</b>
<i>268</i>&nbsp;                &amp;&amp; currentIndexMetaData != null
<b class="fc"><i>269</i>&nbsp;                &amp;&amp; currentIndexMetaData.getCreationVersion().onOrAfter(Version.V_6_5_0)) {</b>
<b class="fc"><i>270</i>&nbsp;            if (currentIndexMetaData.getMappingVersion() == newIndexMetaData.getMappingVersion()) {</b>
<i>271</i>&nbsp;                // if the mapping version is unchanged, then there should not be any updates and all mappings should be the same
<b class="fc"><i>272</i>&nbsp;                assert updatedEntries.isEmpty() : updatedEntries;</b>
<i>273</i>&nbsp;
<b class="fc"><i>274</i>&nbsp;                MappingMetaData defaultMapping = newIndexMetaData.defaultMapping();</b>
<b class="fc"><i>275</i>&nbsp;                if (defaultMapping != null) {</b>
<b class="nc"><i>276</i>&nbsp;                    final CompressedXContent currentSource = currentIndexMetaData.defaultMapping().source();</b>
<b class="nc"><i>277</i>&nbsp;                    final CompressedXContent newSource = defaultMapping.source();</b>
<b class="nc"><i>278</i>&nbsp;                    assert currentSource.equals(newSource) :</b>
<b class="nc"><i>279</i>&nbsp;                            &quot;expected current mapping [&quot; + currentSource + &quot;] for type [&quot; + defaultMapping.type() + &quot;] &quot;</b>
<i>280</i>&nbsp;                                    + &quot;to be the same as new mapping [&quot; + newSource + &quot;]&quot;;
<i>281</i>&nbsp;                }
<i>282</i>&nbsp;
<b class="fc"><i>283</i>&nbsp;                MappingMetaData mapping = newIndexMetaData.mapping();</b>
<b class="fc"><i>284</i>&nbsp;                if (mapping != null) {</b>
<b class="nc"><i>285</i>&nbsp;                    final CompressedXContent currentSource = currentIndexMetaData.mapping().source();</b>
<b class="nc"><i>286</i>&nbsp;                    final CompressedXContent newSource = mapping.source();</b>
<b class="nc"><i>287</i>&nbsp;                    assert currentSource.equals(newSource) :</b>
<b class="nc"><i>288</i>&nbsp;                            &quot;expected current mapping [&quot; + currentSource + &quot;] for type [&quot; + mapping.type() + &quot;] &quot;</b>
<i>289</i>&nbsp;                                    + &quot;to be the same as new mapping [&quot; + newSource + &quot;]&quot;;
<i>290</i>&nbsp;                }
<i>291</i>&nbsp;
<b class="fc"><i>292</i>&nbsp;            } else {</b>
<i>293</i>&nbsp;                // if the mapping version is changed, it should increase, there should be updates, and the mapping should be different
<b class="nc"><i>294</i>&nbsp;                final long currentMappingVersion = currentIndexMetaData.getMappingVersion();</b>
<b class="nc"><i>295</i>&nbsp;                final long newMappingVersion = newIndexMetaData.getMappingVersion();</b>
<b class="nc"><i>296</i>&nbsp;                assert currentMappingVersion &lt; newMappingVersion :</b>
<i>297</i>&nbsp;                        &quot;expected current mapping version [&quot; + currentMappingVersion + &quot;] &quot;
<i>298</i>&nbsp;                                + &quot;to be less than new mapping version [&quot; + newMappingVersion + &quot;]&quot;;
<b class="nc"><i>299</i>&nbsp;                assert updatedEntries.isEmpty() == false;</b>
<b class="nc"><i>300</i>&nbsp;                for (final DocumentMapper documentMapper : updatedEntries.values()) {</b>
<i>301</i>&nbsp;                    final MappingMetaData currentMapping;
<b class="nc"><i>302</i>&nbsp;                    if (documentMapper.type().equals(MapperService.DEFAULT_MAPPING)) {</b>
<b class="nc"><i>303</i>&nbsp;                        currentMapping = currentIndexMetaData.defaultMapping();</b>
<i>304</i>&nbsp;                    } else {
<b class="nc"><i>305</i>&nbsp;                        currentMapping = currentIndexMetaData.mapping();</b>
<b class="nc"><i>306</i>&nbsp;                        assert currentMapping == null || documentMapper.type().equals(currentMapping.type());</b>
<i>307</i>&nbsp;                    }
<b class="nc"><i>308</i>&nbsp;                    if (currentMapping != null) {</b>
<b class="nc"><i>309</i>&nbsp;                        final CompressedXContent currentSource = currentMapping.source();</b>
<b class="nc"><i>310</i>&nbsp;                        final CompressedXContent newSource = documentMapper.mappingSource();</b>
<b class="nc"><i>311</i>&nbsp;                        assert currentSource.equals(newSource) == false :</b>
<b class="nc"><i>312</i>&nbsp;                                &quot;expected current mapping [&quot; + currentSource + &quot;] for type [&quot; + documentMapper.type() + &quot;] &quot; +</b>
<i>313</i>&nbsp;                                        &quot;to be different than new mapping&quot;;
<i>314</i>&nbsp;                    }
<b class="nc"><i>315</i>&nbsp;                }</b>
<i>316</i>&nbsp;            }
<i>317</i>&nbsp;        }
<b class="fc"><i>318</i>&nbsp;    }</b>
<i>319</i>&nbsp;
<i>320</i>&nbsp;    public void merge(Map&lt;String, Map&lt;String, Object&gt;&gt; mappings, MergeReason reason) {
<b class="fc"><i>321</i>&nbsp;        Map&lt;String, CompressedXContent&gt; mappingSourcesCompressed = new LinkedHashMap&lt;&gt;(mappings.size());</b>
<b class="fc"><i>322</i>&nbsp;        for (Map.Entry&lt;String, Map&lt;String, Object&gt;&gt; entry : mappings.entrySet()) {</b>
<i>323</i>&nbsp;            try {
<b class="nc"><i>324</i>&nbsp;                mappingSourcesCompressed.put(entry.getKey(), new CompressedXContent(Strings.toString(</b>
<b class="nc"><i>325</i>&nbsp;                    XContentFactory.jsonBuilder().map(entry.getValue()))));</b>
<b class="nc"><i>326</i>&nbsp;            } catch (Exception e) {</b>
<b class="nc"><i>327</i>&nbsp;                throw new MapperParsingException(&quot;Failed to parse mapping [{}]: {}&quot;, e, entry.getKey(), e.getMessage());</b>
<b class="nc"><i>328</i>&nbsp;            }</b>
<b class="nc"><i>329</i>&nbsp;        }</b>
<i>330</i>&nbsp;
<b class="fc"><i>331</i>&nbsp;        internalMerge(mappingSourcesCompressed, reason);</b>
<b class="fc"><i>332</i>&nbsp;    }</b>
<i>333</i>&nbsp;
<i>334</i>&nbsp;    public void merge(IndexMetaData indexMetaData, MergeReason reason) {
<b class="nc"><i>335</i>&nbsp;        internalMerge(indexMetaData, reason, false);</b>
<b class="nc"><i>336</i>&nbsp;    }</b>
<i>337</i>&nbsp;
<i>338</i>&nbsp;    public DocumentMapper merge(String type, CompressedXContent mappingSource, MergeReason reason) {
<b class="fc"><i>339</i>&nbsp;        return internalMerge(Collections.singletonMap(type, mappingSource), reason).get(type);</b>
<i>340</i>&nbsp;    }
<i>341</i>&nbsp;
<i>342</i>&nbsp;    private synchronized Map&lt;String, DocumentMapper&gt; internalMerge(IndexMetaData indexMetaData,
<i>343</i>&nbsp;                                                                   MergeReason reason, boolean onlyUpdateIfNeeded) {
<b class="fc"><i>344</i>&nbsp;        Map&lt;String, CompressedXContent&gt; map = new LinkedHashMap&lt;&gt;();</b>
<b class="fc"><i>345</i>&nbsp;        for (ObjectCursor&lt;MappingMetaData&gt; cursor : indexMetaData.getMappings().values()) {</b>
<b class="nc"><i>346</i>&nbsp;            MappingMetaData mappingMetaData = cursor.value;</b>
<b class="nc"><i>347</i>&nbsp;            if (onlyUpdateIfNeeded) {</b>
<b class="nc"><i>348</i>&nbsp;                DocumentMapper existingMapper = documentMapper(mappingMetaData.type());</b>
<b class="nc"><i>349</i>&nbsp;                if (existingMapper == null || mappingMetaData.source().equals(existingMapper.mappingSource()) == false) {</b>
<b class="nc"><i>350</i>&nbsp;                    map.put(mappingMetaData.type(), mappingMetaData.source());</b>
<i>351</i>&nbsp;                }
<b class="nc"><i>352</i>&nbsp;            } else {</b>
<b class="nc"><i>353</i>&nbsp;                map.put(mappingMetaData.type(), mappingMetaData.source());</b>
<i>354</i>&nbsp;            }
<b class="nc"><i>355</i>&nbsp;        }</b>
<b class="fc"><i>356</i>&nbsp;        return internalMerge(map, reason);</b>
<i>357</i>&nbsp;    }
<i>358</i>&nbsp;
<i>359</i>&nbsp;    private synchronized Map&lt;String, DocumentMapper&gt; internalMerge(Map&lt;String, CompressedXContent&gt; mappings, MergeReason reason) {
<b class="fc"><i>360</i>&nbsp;        DocumentMapper defaultMapper = null;</b>
<b class="fc"><i>361</i>&nbsp;        String defaultMappingSource = null;</b>
<i>362</i>&nbsp;
<b class="fc"><i>363</i>&nbsp;        if (mappings.containsKey(DEFAULT_MAPPING)) {</b>
<i>364</i>&nbsp;            // verify we can parse it
<i>365</i>&nbsp;            // NOTE: never apply the default here
<i>366</i>&nbsp;            try {
<b class="nc"><i>367</i>&nbsp;                defaultMapper = documentParser.parse(DEFAULT_MAPPING, mappings.get(DEFAULT_MAPPING));</b>
<b class="nc"><i>368</i>&nbsp;            } catch (Exception e) {</b>
<b class="nc"><i>369</i>&nbsp;                throw new MapperParsingException(&quot;Failed to parse mapping [{}]: {}&quot;, e, DEFAULT_MAPPING, e.getMessage());</b>
<b class="nc"><i>370</i>&nbsp;            }</b>
<b class="nc"><i>371</i>&nbsp;            defaultMappingSource = mappings.get(DEFAULT_MAPPING).string();</b>
<i>372</i>&nbsp;        }
<i>373</i>&nbsp;
<i>374</i>&nbsp;        final String defaultMappingSourceOrLastStored;
<b class="fc"><i>375</i>&nbsp;        if (defaultMappingSource != null) {</b>
<b class="nc"><i>376</i>&nbsp;            defaultMappingSourceOrLastStored = defaultMappingSource;</b>
<i>377</i>&nbsp;        } else {
<b class="fc"><i>378</i>&nbsp;            defaultMappingSourceOrLastStored = this.defaultMappingSource;</b>
<i>379</i>&nbsp;        }
<i>380</i>&nbsp;
<b class="fc"><i>381</i>&nbsp;        DocumentMapper documentMapper = null;</b>
<b class="fc"><i>382</i>&nbsp;        for (Map.Entry&lt;String, CompressedXContent&gt; entry : mappings.entrySet()) {</b>
<b class="fc"><i>383</i>&nbsp;            String type = entry.getKey();</b>
<b class="fc"><i>384</i>&nbsp;            if (type.equals(DEFAULT_MAPPING)) {</b>
<b class="nc"><i>385</i>&nbsp;                continue;</b>
<i>386</i>&nbsp;            }
<i>387</i>&nbsp;
<b class="fc"><i>388</i>&nbsp;            if (documentMapper != null) {</b>
<b class="nc"><i>389</i>&nbsp;                throw new IllegalArgumentException(&quot;Cannot put multiple mappings: &quot; + mappings.keySet());</b>
<i>390</i>&nbsp;            }
<i>391</i>&nbsp;
<b class="fc"><i>392</i>&nbsp;            final boolean applyDefault =</b>
<i>393</i>&nbsp;                // the default was already applied if we are recovering
<i>394</i>&nbsp;                reason != MergeReason.MAPPING_RECOVERY
<i>395</i>&nbsp;                    // only apply the default mapping if we don&#39;t have the type yet
<i>396</i>&nbsp;                    &amp;&amp; this.mapper == null;
<i>397</i>&nbsp;
<i>398</i>&nbsp;            try {
<b class="fc"><i>399</i>&nbsp;                documentMapper =</b>
<b class="fc"><i>400</i>&nbsp;                    documentParser.parse(type, entry.getValue(), applyDefault ? defaultMappingSourceOrLastStored : null);</b>
<b class="fc"><i>401</i>&nbsp;            } catch (Exception e) {</b>
<b class="fc"><i>402</i>&nbsp;                throw new MapperParsingException(&quot;Failed to parse mapping [{}]: {}&quot;, e, entry.getKey(), e.getMessage());</b>
<b class="fc"><i>403</i>&nbsp;            }</b>
<b class="fc"><i>404</i>&nbsp;        }</b>
<i>405</i>&nbsp;
<b class="fc"><i>406</i>&nbsp;        return internalMerge(defaultMapper, defaultMappingSource, documentMapper, reason);</b>
<i>407</i>&nbsp;    }
<i>408</i>&nbsp;
<i>409</i>&nbsp;    static void validateTypeName(String type) {
<b class="fc"><i>410</i>&nbsp;        if (type.length() == 0) {</b>
<b class="nc"><i>411</i>&nbsp;            throw new InvalidTypeNameException(&quot;mapping type name is empty&quot;);</b>
<i>412</i>&nbsp;        }
<b class="fc"><i>413</i>&nbsp;        if (type.length() &gt; 255) {</b>
<b class="nc"><i>414</i>&nbsp;            throw new InvalidTypeNameException(&quot;mapping type name [&quot; + type + &quot;] is too long; limit is length 255 but was [&quot;</b>
<b class="nc"><i>415</i>&nbsp;                + type.length() + &quot;]&quot;);</b>
<i>416</i>&nbsp;        }
<b class="fc"><i>417</i>&nbsp;        if (type.charAt(0) == &#39;_&#39; &amp;&amp; SINGLE_MAPPING_NAME.equals(type) == false) {</b>
<b class="nc"><i>418</i>&nbsp;            throw new InvalidTypeNameException(&quot;mapping type name [&quot; + type + &quot;] can&#39;t start with &#39;_&#39; unless it is called [&quot;</b>
<i>419</i>&nbsp;                + SINGLE_MAPPING_NAME + &quot;]&quot;);
<i>420</i>&nbsp;        }
<b class="fc"><i>421</i>&nbsp;        if (type.contains(&quot;#&quot;)) {</b>
<b class="nc"><i>422</i>&nbsp;            throw new InvalidTypeNameException(&quot;mapping type name [&quot; + type + &quot;] should not include &#39;#&#39; in it&quot;);</b>
<i>423</i>&nbsp;        }
<b class="fc"><i>424</i>&nbsp;        if (type.contains(&quot;,&quot;)) {</b>
<b class="nc"><i>425</i>&nbsp;            throw new InvalidTypeNameException(&quot;mapping type name [&quot; + type + &quot;] should not include &#39;,&#39; in it&quot;);</b>
<i>426</i>&nbsp;        }
<b class="fc"><i>427</i>&nbsp;        if (type.charAt(0) == &#39;.&#39;) {</b>
<b class="nc"><i>428</i>&nbsp;            throw new IllegalArgumentException(&quot;mapping type name [&quot; + type + &quot;] must not start with a &#39;.&#39;&quot;);</b>
<i>429</i>&nbsp;        }
<b class="fc"><i>430</i>&nbsp;    }</b>
<i>431</i>&nbsp;
<i>432</i>&nbsp;    private synchronized Map&lt;String, DocumentMapper&gt; internalMerge(@Nullable DocumentMapper defaultMapper,
<i>433</i>&nbsp;                                                                   @Nullable String defaultMappingSource, DocumentMapper mapper,
<i>434</i>&nbsp;                                                                   MergeReason reason) {
<b class="fc"><i>435</i>&nbsp;        boolean hasNested = this.hasNested;</b>
<b class="fc"><i>436</i>&nbsp;        Map&lt;String, ObjectMapper&gt; fullPathObjectMappers = this.fullPathObjectMappers;</b>
<b class="fc"><i>437</i>&nbsp;        FieldTypeLookup fieldTypes = this.fieldTypes;</b>
<i>438</i>&nbsp;
<b class="fc"><i>439</i>&nbsp;        Map&lt;String, DocumentMapper&gt; results = new LinkedHashMap&lt;&gt;(2);</b>
<i>440</i>&nbsp;
<b class="fc"><i>441</i>&nbsp;        if (defaultMapper != null) {</b>
<b class="nc"><i>442</i>&nbsp;            if (indexSettings.getIndexVersionCreated().onOrAfter(Version.V_7_0_0)) {</b>
<b class="nc"><i>443</i>&nbsp;                throw new IllegalArgumentException(&quot;The [default] mapping cannot be updated on index [&quot; + index().getName() +</b>
<i>444</i>&nbsp;                        &quot;]: defaults mappings are not useful anymore now that indices can have at most one type.&quot;);
<b class="nc"><i>445</i>&nbsp;            } else if (reason == MergeReason.MAPPING_UPDATE) { // only log in case of explicit mapping updates</b>
<b class="nc"><i>446</i>&nbsp;                deprecationLogger.deprecated(&quot;[_default_] mapping is deprecated since it is not useful anymore now that indexes &quot; +</b>
<i>447</i>&nbsp;                        &quot;cannot have more than one type&quot;);
<i>448</i>&nbsp;            }
<b class="nc"><i>449</i>&nbsp;            assert defaultMapper.type().equals(DEFAULT_MAPPING);</b>
<b class="nc"><i>450</i>&nbsp;            results.put(DEFAULT_MAPPING, defaultMapper);</b>
<i>451</i>&nbsp;        }
<i>452</i>&nbsp;
<b class="fc"><i>453</i>&nbsp;        DocumentMapper newMapper = null;</b>
<b class="fc"><i>454</i>&nbsp;        if (mapper != null) {</b>
<i>455</i>&nbsp;            // check naming
<b class="fc"><i>456</i>&nbsp;            validateTypeName(mapper.type());</b>
<i>457</i>&nbsp;
<i>458</i>&nbsp;            // compute the merged DocumentMapper
<b class="fc"><i>459</i>&nbsp;            DocumentMapper oldMapper = this.mapper;</b>
<b class="fc"><i>460</i>&nbsp;            if (oldMapper != null) {</b>
<b class="fc"><i>461</i>&nbsp;                newMapper = oldMapper.merge(mapper.mapping());</b>
<i>462</i>&nbsp;            } else {
<b class="fc"><i>463</i>&nbsp;                newMapper = mapper;</b>
<i>464</i>&nbsp;            }
<i>465</i>&nbsp;
<i>466</i>&nbsp;            // check basic sanity of the new mapping
<b class="fc"><i>467</i>&nbsp;            List&lt;ObjectMapper&gt; objectMappers = new ArrayList&lt;&gt;();</b>
<b class="fc"><i>468</i>&nbsp;            List&lt;FieldMapper&gt; fieldMappers = new ArrayList&lt;&gt;();</b>
<b class="fc"><i>469</i>&nbsp;            List&lt;FieldAliasMapper&gt; fieldAliasMappers = new ArrayList&lt;&gt;();</b>
<b class="fc"><i>470</i>&nbsp;            MetadataFieldMapper[] metadataMappers = newMapper.mapping().metadataMappers;</b>
<b class="fc"><i>471</i>&nbsp;            Collections.addAll(fieldMappers, metadataMappers);</b>
<b class="fc"><i>472</i>&nbsp;            MapperUtils.collect(newMapper.mapping().root(), objectMappers, fieldMappers, fieldAliasMappers);</b>
<i>473</i>&nbsp;
<b class="fc"><i>474</i>&nbsp;            MapperMergeValidator.validateNewMappers(objectMappers, fieldMappers, fieldAliasMappers, fieldTypes);</b>
<b class="fc"><i>475</i>&nbsp;            checkPartitionedIndexConstraints(newMapper);</b>
<i>476</i>&nbsp;
<i>477</i>&nbsp;            // update lookup data-structures
<b class="fc"><i>478</i>&nbsp;            fieldTypes = fieldTypes.copyAndAddAll(newMapper.type(), fieldMappers, fieldAliasMappers);</b>
<i>479</i>&nbsp;
<b class="fc"><i>480</i>&nbsp;            for (ObjectMapper objectMapper : objectMappers) {</b>
<b class="fc"><i>481</i>&nbsp;                if (fullPathObjectMappers == this.fullPathObjectMappers) {</b>
<i>482</i>&nbsp;                    // first time through the loops
<b class="fc"><i>483</i>&nbsp;                    fullPathObjectMappers = new HashMap&lt;&gt;(this.fullPathObjectMappers);</b>
<i>484</i>&nbsp;                }
<b class="fc"><i>485</i>&nbsp;                fullPathObjectMappers.put(objectMapper.fullPath(), objectMapper);</b>
<i>486</i>&nbsp;
<b class="fc"><i>487</i>&nbsp;                if (objectMapper.nested().isNested()) {</b>
<b class="nc"><i>488</i>&nbsp;                    hasNested = true;</b>
<i>489</i>&nbsp;                }
<b class="fc"><i>490</i>&nbsp;            }</b>
<i>491</i>&nbsp;
<b class="fc"><i>492</i>&nbsp;            MapperMergeValidator.validateFieldReferences(fieldMappers, fieldAliasMappers,</b>
<i>493</i>&nbsp;                fullPathObjectMappers, fieldTypes);
<i>494</i>&nbsp;
<b class="fc"><i>495</i>&nbsp;            ContextMapping.validateContextPaths(indexSettings.getIndexVersionCreated(), fieldMappers, fieldTypes::get);</b>
<i>496</i>&nbsp;
<b class="fc"><i>497</i>&nbsp;            if (reason == MergeReason.MAPPING_UPDATE) {</b>
<i>498</i>&nbsp;                // this check will only be performed on the master node when there is
<i>499</i>&nbsp;                // a call to the update mapping API. For all other cases like
<i>500</i>&nbsp;                // the master node restoring mappings from disk or data nodes
<i>501</i>&nbsp;                // deserializing cluster state that was sent by the master node,
<i>502</i>&nbsp;                // this check will be skipped.
<i>503</i>&nbsp;                // Also, don&#39;t take metadata mappers into account for the field limit check
<b class="fc"><i>504</i>&nbsp;                checkTotalFieldsLimit(objectMappers.size() + fieldMappers.size() - metadataMappers.length</b>
<b class="fc"><i>505</i>&nbsp;                    + fieldAliasMappers.size() );</b>
<b class="fc"><i>506</i>&nbsp;                checkFieldNameSoftLimit(objectMappers, fieldMappers, fieldAliasMappers);</b>
<i>507</i>&nbsp;            }
<i>508</i>&nbsp;
<b class="fc"><i>509</i>&nbsp;            results.put(newMapper.type(), newMapper);</b>
<i>510</i>&nbsp;        }
<i>511</i>&nbsp;
<b class="fc"><i>512</i>&nbsp;        if (reason == MergeReason.MAPPING_UPDATE) {</b>
<i>513</i>&nbsp;            // this check will only be performed on the master node when there is
<i>514</i>&nbsp;            // a call to the update mapping API. For all other cases like
<i>515</i>&nbsp;            // the master node restoring mappings from disk or data nodes
<i>516</i>&nbsp;            // deserializing cluster state that was sent by the master node,
<i>517</i>&nbsp;            // this check will be skipped.
<b class="fc"><i>518</i>&nbsp;            checkNestedFieldsLimit(fullPathObjectMappers);</b>
<b class="fc"><i>519</i>&nbsp;            checkDepthLimit(fullPathObjectMappers.keySet());</b>
<i>520</i>&nbsp;        }
<b class="fc"><i>521</i>&nbsp;        checkIndexSortCompatibility(indexSettings.getIndexSortConfig(), hasNested);</b>
<i>522</i>&nbsp;
<b class="fc"><i>523</i>&nbsp;        if (newMapper != null) {</b>
<b class="fc"><i>524</i>&nbsp;            DocumentMapper updatedDocumentMapper = newMapper.updateFieldType(fieldTypes.fullNameToFieldType);</b>
<b class="fc"><i>525</i>&nbsp;            if (updatedDocumentMapper != newMapper) {</b>
<i>526</i>&nbsp;                // update both mappers and result
<b class="fc"><i>527</i>&nbsp;                newMapper = updatedDocumentMapper;</b>
<b class="fc"><i>528</i>&nbsp;                results.put(updatedDocumentMapper.type(), updatedDocumentMapper);</b>
<i>529</i>&nbsp;            }
<i>530</i>&nbsp;        }
<i>531</i>&nbsp;
<i>532</i>&nbsp;        // make structures immutable
<b class="fc"><i>533</i>&nbsp;        results = Collections.unmodifiableMap(results);</b>
<i>534</i>&nbsp;
<i>535</i>&nbsp;        // only need to immutably rewrap these if the previous reference was changed.
<i>536</i>&nbsp;        // if not then they are already implicitly immutable.
<b class="fc"><i>537</i>&nbsp;        if (fullPathObjectMappers != this.fullPathObjectMappers) {</b>
<b class="fc"><i>538</i>&nbsp;            fullPathObjectMappers = Collections.unmodifiableMap(fullPathObjectMappers);</b>
<i>539</i>&nbsp;        }
<i>540</i>&nbsp;
<i>541</i>&nbsp;        // commit the change
<b class="fc"><i>542</i>&nbsp;        if (defaultMappingSource != null) {</b>
<b class="nc"><i>543</i>&nbsp;            this.defaultMappingSource = defaultMappingSource;</b>
<b class="nc"><i>544</i>&nbsp;            this.defaultMapper = defaultMapper;</b>
<i>545</i>&nbsp;        }
<b class="fc"><i>546</i>&nbsp;        if (newMapper != null) {</b>
<b class="fc"><i>547</i>&nbsp;            this.mapper = newMapper;</b>
<i>548</i>&nbsp;        }
<b class="fc"><i>549</i>&nbsp;        this.fieldTypes = fieldTypes;</b>
<b class="fc"><i>550</i>&nbsp;        this.hasNested = hasNested;</b>
<b class="fc"><i>551</i>&nbsp;        this.fullPathObjectMappers = fullPathObjectMappers;</b>
<i>552</i>&nbsp;
<b class="fc"><i>553</i>&nbsp;        assert assertMappersShareSameFieldType();</b>
<b class="fc"><i>554</i>&nbsp;        assert results.values().stream().allMatch(this::assertSerialization);</b>
<i>555</i>&nbsp;
<b class="fc"><i>556</i>&nbsp;        return results;</b>
<i>557</i>&nbsp;    }
<i>558</i>&nbsp;
<i>559</i>&nbsp;    private boolean assertMappersShareSameFieldType() {
<b class="fc"><i>560</i>&nbsp;        if (mapper != null) {</b>
<b class="fc"><i>561</i>&nbsp;            List&lt;FieldMapper&gt; fieldMappers = new ArrayList&lt;&gt;();</b>
<b class="fc"><i>562</i>&nbsp;            Collections.addAll(fieldMappers, mapper.mapping().metadataMappers);</b>
<b class="fc"><i>563</i>&nbsp;            MapperUtils.collect(mapper.root(), new ArrayList&lt;&gt;(), fieldMappers, new ArrayList&lt;&gt;());</b>
<b class="fc"><i>564</i>&nbsp;            for (FieldMapper fieldMapper : fieldMappers) {</b>
<b class="fc"><i>565</i>&nbsp;                assert fieldMapper.fieldType() == fieldTypes.get(fieldMapper.name()) : fieldMapper.name();</b>
<b class="fc"><i>566</i>&nbsp;            }</b>
<i>567</i>&nbsp;        }
<b class="fc"><i>568</i>&nbsp;        return true;</b>
<i>569</i>&nbsp;    }
<i>570</i>&nbsp;
<i>571</i>&nbsp;    private boolean assertSerialization(DocumentMapper mapper) {
<i>572</i>&nbsp;        // capture the source now, it may change due to concurrent parsing
<b class="fc"><i>573</i>&nbsp;        final CompressedXContent mappingSource = mapper.mappingSource();</b>
<b class="fc"><i>574</i>&nbsp;        DocumentMapper newMapper = parse(mapper.type(), mappingSource, false);</b>
<i>575</i>&nbsp;
<b class="fc"><i>576</i>&nbsp;        if (newMapper.mappingSource().equals(mappingSource) == false) {</b>
<b class="nc"><i>577</i>&nbsp;            throw new IllegalStateException(&quot;DocumentMapper serialization result is different from source. \n--&gt; Source [&quot;</b>
<i>578</i>&nbsp;                + mappingSource + &quot;]\n--&gt; Result [&quot;
<b class="nc"><i>579</i>&nbsp;                + newMapper.mappingSource() + &quot;]&quot;);</b>
<i>580</i>&nbsp;        }
<b class="fc"><i>581</i>&nbsp;        return true;</b>
<i>582</i>&nbsp;    }
<i>583</i>&nbsp;
<i>584</i>&nbsp;    private void checkNestedFieldsLimit(Map&lt;String, ObjectMapper&gt; fullPathObjectMappers) {
<b class="fc"><i>585</i>&nbsp;        long allowedNestedFields = indexSettings.getValue(INDEX_MAPPING_NESTED_FIELDS_LIMIT_SETTING);</b>
<b class="fc"><i>586</i>&nbsp;        long actualNestedFields = 0;</b>
<b class="fc"><i>587</i>&nbsp;        for (ObjectMapper objectMapper : fullPathObjectMappers.values()) {</b>
<b class="fc"><i>588</i>&nbsp;            if (objectMapper.nested().isNested()) {</b>
<b class="nc"><i>589</i>&nbsp;                actualNestedFields++;</b>
<i>590</i>&nbsp;            }
<b class="fc"><i>591</i>&nbsp;        }</b>
<b class="fc"><i>592</i>&nbsp;        if (actualNestedFields &gt; allowedNestedFields) {</b>
<b class="nc"><i>593</i>&nbsp;            throw new IllegalArgumentException(&quot;Limit of nested fields [&quot; + allowedNestedFields + &quot;] in index [&quot; + index().getName()</b>
<i>594</i>&nbsp;                + &quot;] has been exceeded&quot;);
<i>595</i>&nbsp;        }
<b class="fc"><i>596</i>&nbsp;    }</b>
<i>597</i>&nbsp;
<i>598</i>&nbsp;    private void checkTotalFieldsLimit(long totalMappers) {
<b class="fc"><i>599</i>&nbsp;        long allowedTotalFields = indexSettings.getValue(INDEX_MAPPING_TOTAL_FIELDS_LIMIT_SETTING);</b>
<b class="fc"><i>600</i>&nbsp;        if (allowedTotalFields &lt; totalMappers) {</b>
<b class="nc"><i>601</i>&nbsp;            throw new IllegalArgumentException(&quot;Limit of total fields [&quot; + allowedTotalFields + &quot;] in index [&quot; + index().getName()</b>
<i>602</i>&nbsp;                + &quot;] has been exceeded&quot;);
<i>603</i>&nbsp;        }
<b class="fc"><i>604</i>&nbsp;    }</b>
<i>605</i>&nbsp;
<i>606</i>&nbsp;    private void checkDepthLimit(Collection&lt;String&gt; objectPaths) {
<b class="fc"><i>607</i>&nbsp;        final long maxDepth = indexSettings.getValue(INDEX_MAPPING_DEPTH_LIMIT_SETTING);</b>
<b class="fc"><i>608</i>&nbsp;        for (String objectPath : objectPaths) {</b>
<b class="fc"><i>609</i>&nbsp;            checkDepthLimit(objectPath, maxDepth);</b>
<b class="fc"><i>610</i>&nbsp;        }</b>
<b class="fc"><i>611</i>&nbsp;    }</b>
<i>612</i>&nbsp;
<i>613</i>&nbsp;    private void checkDepthLimit(String objectPath, long maxDepth) {
<b class="fc"><i>614</i>&nbsp;        int numDots = 0;</b>
<b class="fc"><i>615</i>&nbsp;        for (int i = 0; i &lt; objectPath.length(); ++i) {</b>
<b class="fc"><i>616</i>&nbsp;            if (objectPath.charAt(i) == &#39;.&#39;) {</b>
<b class="nc"><i>617</i>&nbsp;                numDots += 1;</b>
<i>618</i>&nbsp;            }
<i>619</i>&nbsp;        }
<b class="fc"><i>620</i>&nbsp;        final int depth = numDots + 2;</b>
<b class="fc"><i>621</i>&nbsp;        if (depth &gt; maxDepth) {</b>
<b class="nc"><i>622</i>&nbsp;            throw new IllegalArgumentException(&quot;Limit of mapping depth [&quot; + maxDepth + &quot;] in index [&quot; + index().getName()</b>
<i>623</i>&nbsp;                    + &quot;] has been exceeded due to object field [&quot; + objectPath + &quot;]&quot;);
<i>624</i>&nbsp;        }
<b class="fc"><i>625</i>&nbsp;    }</b>
<i>626</i>&nbsp;
<i>627</i>&nbsp;    private void checkFieldNameSoftLimit(Collection&lt;ObjectMapper&gt; objectMappers,
<i>628</i>&nbsp;                                         Collection&lt;FieldMapper&gt; fieldMappers,
<i>629</i>&nbsp;                                         Collection&lt;FieldAliasMapper&gt; fieldAliasMappers) {
<b class="fc"><i>630</i>&nbsp;        final long maxFieldNameLength = indexSettings.getValue(INDEX_MAPPING_FIELD_NAME_LENGTH_LIMIT_SETTING);</b>
<i>631</i>&nbsp;
<b class="fc"><i>632</i>&nbsp;        Stream.of(objectMappers.stream(), fieldMappers.stream(), fieldAliasMappers.stream())</b>
<b class="fc"><i>633</i>&nbsp;            .reduce(Stream::concat)</b>
<b class="fc"><i>634</i>&nbsp;            .orElseGet(Stream::empty)</b>
<b class="fc"><i>635</i>&nbsp;            .forEach(mapper -&gt; {</b>
<b class="fc"><i>636</i>&nbsp;                String name = mapper.simpleName();</b>
<b class="fc"><i>637</i>&nbsp;                if (name.length() &gt; maxFieldNameLength) {</b>
<b class="nc"><i>638</i>&nbsp;                    throw new IllegalArgumentException(&quot;Field name [&quot; + name + &quot;] in index [&quot; + index().getName() +</b>
<i>639</i>&nbsp;                        &quot;] is too long. The limit is set to [&quot; + maxFieldNameLength + &quot;] characters but was [&quot;
<b class="nc"><i>640</i>&nbsp;                        + name.length() + &quot;] characters&quot;);</b>
<i>641</i>&nbsp;                }
<b class="fc"><i>642</i>&nbsp;            });</b>
<b class="fc"><i>643</i>&nbsp;    }</b>
<i>644</i>&nbsp;
<i>645</i>&nbsp;    private void checkPartitionedIndexConstraints(DocumentMapper newMapper) {
<b class="fc"><i>646</i>&nbsp;        if (indexSettings.getIndexMetaData().isRoutingPartitionedIndex()) {</b>
<b class="nc"><i>647</i>&nbsp;            if (!newMapper.routingFieldMapper().required()) {</b>
<b class="nc"><i>648</i>&nbsp;                throw new IllegalArgumentException(&quot;mapping type [&quot; + newMapper.type() + &quot;] must have routing &quot;</b>
<b class="nc"><i>649</i>&nbsp;                        + &quot;required for partitioned index [&quot; + indexSettings.getIndex().getName() + &quot;]&quot;);</b>
<i>650</i>&nbsp;            }
<i>651</i>&nbsp;        }
<b class="fc"><i>652</i>&nbsp;    }</b>
<i>653</i>&nbsp;
<i>654</i>&nbsp;    private static void checkIndexSortCompatibility(IndexSortConfig sortConfig, boolean hasNested) {
<b class="fc"><i>655</i>&nbsp;        if (sortConfig.hasIndexSort() &amp;&amp; hasNested) {</b>
<b class="nc"><i>656</i>&nbsp;            throw new IllegalArgumentException(&quot;cannot have nested fields when index sort is activated&quot;);</b>
<i>657</i>&nbsp;        }
<b class="fc"><i>658</i>&nbsp;    }</b>
<i>659</i>&nbsp;
<i>660</i>&nbsp;    public DocumentMapper parse(String mappingType, CompressedXContent mappingSource, boolean applyDefault) throws MapperParsingException {
<b class="fc"><i>661</i>&nbsp;        return documentParser.parse(mappingType, mappingSource, applyDefault ? defaultMappingSource : null);</b>
<i>662</i>&nbsp;    }
<i>663</i>&nbsp;
<i>664</i>&nbsp;    /**
<i>665</i>&nbsp;     * Return the document mapper, or {@code null} if no mapping has been put yet.
<i>666</i>&nbsp;     */
<i>667</i>&nbsp;    public DocumentMapper documentMapper() {
<b class="fc"><i>668</i>&nbsp;        return mapper;</b>
<i>669</i>&nbsp;    }
<i>670</i>&nbsp;
<i>671</i>&nbsp;    /**
<i>672</i>&nbsp;     * Return the {@link DocumentMapper} for the given type. By using the special
<i>673</i>&nbsp;     * {@value #DEFAULT_MAPPING} type, you can get a {@link DocumentMapper} for
<i>674</i>&nbsp;     * the default mapping.
<i>675</i>&nbsp;     */
<i>676</i>&nbsp;    public DocumentMapper documentMapper(String type) {
<b class="fc"><i>677</i>&nbsp;        if (mapper != null &amp;&amp; type.equals(mapper.type())) {</b>
<b class="fc"><i>678</i>&nbsp;            return mapper;</b>
<i>679</i>&nbsp;        }
<b class="fc"><i>680</i>&nbsp;        if (DEFAULT_MAPPING.equals(type)) {</b>
<b class="fc"><i>681</i>&nbsp;            return defaultMapper;</b>
<i>682</i>&nbsp;        }
<b class="fc"><i>683</i>&nbsp;        return null;</b>
<i>684</i>&nbsp;    }
<i>685</i>&nbsp;
<i>686</i>&nbsp;    /**
<i>687</i>&nbsp;     * Returns {@code true} if the given {@code mappingSource} includes a type
<i>688</i>&nbsp;     * as a top-level object.
<i>689</i>&nbsp;     */
<i>690</i>&nbsp;    public static boolean isMappingSourceTyped(String type, Map&lt;String, Object&gt; mapping) {
<b class="nc"><i>691</i>&nbsp;        return mapping.size() == 1 &amp;&amp; mapping.keySet().iterator().next().equals(type);</b>
<i>692</i>&nbsp;    }
<i>693</i>&nbsp;
<i>694</i>&nbsp;
<i>695</i>&nbsp;    public static boolean isMappingSourceTyped(String type, CompressedXContent mappingSource) {
<b class="nc"><i>696</i>&nbsp;        Map&lt;String, Object&gt; root = XContentHelper.convertToMap(mappingSource.compressedReference(), true, XContentType.JSON).v2();</b>
<b class="nc"><i>697</i>&nbsp;        return isMappingSourceTyped(type, root);</b>
<i>698</i>&nbsp;    }
<i>699</i>&nbsp;
<i>700</i>&nbsp;    /**
<i>701</i>&nbsp;     * If the _type name is _doc and there is no _doc top-level key then this means that we
<i>702</i>&nbsp;     * are handling a typeless call. In such a case, we override _doc with the actual type
<i>703</i>&nbsp;     * name in the mappings. This allows to use typeless APIs on typed indices.
<i>704</i>&nbsp;     */
<i>705</i>&nbsp;    public String getTypeForUpdate(String type, CompressedXContent mappingSource) {
<b class="nc"><i>706</i>&nbsp;        return isMappingSourceTyped(type, mappingSource) == false ? resolveDocumentType(type) : type;</b>
<i>707</i>&nbsp;    }
<i>708</i>&nbsp;
<i>709</i>&nbsp;    /**
<i>710</i>&nbsp;     * Resolves a type from a mapping-related request into the type that should be used when
<i>711</i>&nbsp;     * merging and updating mappings.
<i>712</i>&nbsp;     *
<i>713</i>&nbsp;     * If the special `_doc` type is provided, then we replace it with the actual type that is
<i>714</i>&nbsp;     * being used in the mappings. This allows typeless APIs such as &#39;index&#39; or &#39;put mappings&#39;
<i>715</i>&nbsp;     * to work against indices with a custom type name.
<i>716</i>&nbsp;     */
<i>717</i>&nbsp;    public String resolveDocumentType(String type) {
<b class="fc"><i>718</i>&nbsp;        if (MapperService.SINGLE_MAPPING_NAME.equals(type)) {</b>
<b class="fc"><i>719</i>&nbsp;            if (mapper != null) {</b>
<b class="fc"><i>720</i>&nbsp;                return mapper.type();</b>
<i>721</i>&nbsp;            }
<i>722</i>&nbsp;        }
<b class="fc"><i>723</i>&nbsp;        return type;</b>
<i>724</i>&nbsp;    }
<i>725</i>&nbsp;
<i>726</i>&nbsp;    /**
<i>727</i>&nbsp;     * Returns the document mapper created, including a mapping update if the
<i>728</i>&nbsp;     * type has been dynamically created.
<i>729</i>&nbsp;     */
<i>730</i>&nbsp;    public DocumentMapperForType documentMapperWithAutoCreate(String type) {
<b class="nc"><i>731</i>&nbsp;        DocumentMapper mapper = documentMapper(type);</b>
<b class="nc"><i>732</i>&nbsp;        if (mapper != null) {</b>
<b class="nc"><i>733</i>&nbsp;            return new DocumentMapperForType(mapper, null);</b>
<i>734</i>&nbsp;        }
<b class="nc"><i>735</i>&nbsp;        mapper = parse(type, null, true);</b>
<b class="nc"><i>736</i>&nbsp;        return new DocumentMapperForType(mapper, mapper.mapping());</b>
<i>737</i>&nbsp;    }
<i>738</i>&nbsp;
<i>739</i>&nbsp;    /**
<i>740</i>&nbsp;     * Returns the {@link MappedFieldType} for the give fullName.
<i>741</i>&nbsp;     *
<i>742</i>&nbsp;     * If multiple types have fields with the same full name, the first is returned.
<i>743</i>&nbsp;     */
<i>744</i>&nbsp;    public MappedFieldType fullName(String fullName) {
<b class="fc"><i>745</i>&nbsp;        return fieldTypes.get(fullName);</b>
<i>746</i>&nbsp;    }
<i>747</i>&nbsp;
<i>748</i>&nbsp;    /**
<i>749</i>&nbsp;     * Returns all the fields that match the given pattern. If the pattern is prefixed with a type
<i>750</i>&nbsp;     * then the fields will be returned with a type prefix.
<i>751</i>&nbsp;     */
<i>752</i>&nbsp;    public Set&lt;String&gt; simpleMatchToFullName(String pattern) {
<b class="nc"><i>753</i>&nbsp;        if (Regex.isSimpleMatchPattern(pattern) == false) {</b>
<i>754</i>&nbsp;            // no wildcards
<b class="nc"><i>755</i>&nbsp;            return Collections.singleton(pattern);</b>
<i>756</i>&nbsp;        }
<b class="nc"><i>757</i>&nbsp;        return fieldTypes.simpleMatchToFullName(pattern);</b>
<i>758</i>&nbsp;    }
<i>759</i>&nbsp;
<i>760</i>&nbsp;    /**
<i>761</i>&nbsp;     * Returns all mapped field types.
<i>762</i>&nbsp;     */
<i>763</i>&nbsp;    public Iterable&lt;MappedFieldType&gt; fieldTypes() {
<b class="fc"><i>764</i>&nbsp;        return fieldTypes;</b>
<i>765</i>&nbsp;    }
<i>766</i>&nbsp;
<i>767</i>&nbsp;    public ObjectMapper getObjectMapper(String name) {
<b class="nc"><i>768</i>&nbsp;        return fullPathObjectMappers.get(name);</b>
<i>769</i>&nbsp;    }
<i>770</i>&nbsp;
<i>771</i>&nbsp;    /**
<i>772</i>&nbsp;     * Given a type (eg. long, string, ...), return an anonymous field mapper that can be used for search operations.
<i>773</i>&nbsp;     */
<i>774</i>&nbsp;    public MappedFieldType unmappedFieldType(String type) {
<b class="nc"><i>775</i>&nbsp;        if (type.equals(&quot;string&quot;)) {</b>
<b class="nc"><i>776</i>&nbsp;            deprecationLogger.deprecated(&quot;[unmapped_type:string] should be replaced with [unmapped_type:keyword]&quot;);</b>
<b class="nc"><i>777</i>&nbsp;            type = &quot;keyword&quot;;</b>
<i>778</i>&nbsp;        }
<b class="nc"><i>779</i>&nbsp;        MappedFieldType fieldType = unmappedFieldTypes.get(type);</b>
<b class="nc"><i>780</i>&nbsp;        if (fieldType == null) {</b>
<b class="nc"><i>781</i>&nbsp;            final Mapper.TypeParser.ParserContext parserContext = documentMapperParser().parserContext();</b>
<b class="nc"><i>782</i>&nbsp;            Mapper.TypeParser typeParser = parserContext.typeParser(type);</b>
<b class="nc"><i>783</i>&nbsp;            if (typeParser == null) {</b>
<b class="nc"><i>784</i>&nbsp;                throw new IllegalArgumentException(&quot;No mapper found for type [&quot; + type + &quot;]&quot;);</b>
<i>785</i>&nbsp;            }
<b class="nc"><i>786</i>&nbsp;            final Mapper.Builder&lt;?, ?&gt; builder = typeParser.parse(&quot;__anonymous_&quot; + type, emptyMap(), parserContext);</b>
<b class="nc"><i>787</i>&nbsp;            final BuilderContext builderContext = new BuilderContext(indexSettings.getSettings(), new ContentPath(1));</b>
<b class="nc"><i>788</i>&nbsp;            fieldType = ((FieldMapper)builder.build(builderContext)).fieldType();</b>
<i>789</i>&nbsp;
<i>790</i>&nbsp;            // There is no need to synchronize writes here. In the case of concurrent access, we could just
<i>791</i>&nbsp;            // compute some mappers several times, which is not a big deal
<b class="nc"><i>792</i>&nbsp;            Map&lt;String, MappedFieldType&gt; newUnmappedFieldTypes = new HashMap&lt;&gt;(unmappedFieldTypes);</b>
<b class="nc"><i>793</i>&nbsp;            newUnmappedFieldTypes.put(type, fieldType);</b>
<b class="nc"><i>794</i>&nbsp;            unmappedFieldTypes = unmodifiableMap(newUnmappedFieldTypes);</b>
<i>795</i>&nbsp;        }
<b class="nc"><i>796</i>&nbsp;        return fieldType;</b>
<i>797</i>&nbsp;    }
<i>798</i>&nbsp;
<i>799</i>&nbsp;    public Analyzer indexAnalyzer() {
<b class="fc"><i>800</i>&nbsp;        return this.indexAnalyzer;</b>
<i>801</i>&nbsp;    }
<i>802</i>&nbsp;
<i>803</i>&nbsp;    public Analyzer searchAnalyzer() {
<b class="nc"><i>804</i>&nbsp;        return this.searchAnalyzer;</b>
<i>805</i>&nbsp;    }
<i>806</i>&nbsp;
<i>807</i>&nbsp;    public Analyzer searchQuoteAnalyzer() {
<b class="nc"><i>808</i>&nbsp;        return this.searchQuoteAnalyzer;</b>
<i>809</i>&nbsp;    }
<i>810</i>&nbsp;
<i>811</i>&nbsp;    @Override
<i>812</i>&nbsp;    public void close() throws IOException {
<b class="fc"><i>813</i>&nbsp;        indexAnalyzers.close();</b>
<b class="fc"><i>814</i>&nbsp;    }</b>
<i>815</i>&nbsp;
<i>816</i>&nbsp;    /**
<i>817</i>&nbsp;     * @return Whether a field is a metadata field.
<i>818</i>&nbsp;     */
<i>819</i>&nbsp;    public static boolean isMetadataField(String fieldName) {
<b class="fc"><i>820</i>&nbsp;        return META_FIELDS.contains(fieldName);</b>
<i>821</i>&nbsp;    }
<i>822</i>&nbsp;
<i>823</i>&nbsp;    public static String[] getAllMetaFields() {
<b class="nc"><i>824</i>&nbsp;        return Arrays.copyOf(SORTED_META_FIELDS, SORTED_META_FIELDS.length);</b>
<i>825</i>&nbsp;    }
<i>826</i>&nbsp;
<i>827</i>&nbsp;    /** An analyzer wrapper that can lookup fields within the index mappings */
<i>828</i>&nbsp;    final class MapperAnalyzerWrapper extends DelegatingAnalyzerWrapper {
<i>829</i>&nbsp;
<i>830</i>&nbsp;        private final Analyzer defaultAnalyzer;
<i>831</i>&nbsp;        private final Function&lt;MappedFieldType, Analyzer&gt; extractAnalyzer;
<i>832</i>&nbsp;
<b class="fc"><i>833</i>&nbsp;        MapperAnalyzerWrapper(Analyzer defaultAnalyzer, Function&lt;MappedFieldType, Analyzer&gt; extractAnalyzer) {</b>
<b class="fc"><i>834</i>&nbsp;            super(Analyzer.PER_FIELD_REUSE_STRATEGY);</b>
<b class="fc"><i>835</i>&nbsp;            this.defaultAnalyzer = defaultAnalyzer;</b>
<b class="fc"><i>836</i>&nbsp;            this.extractAnalyzer = extractAnalyzer;</b>
<b class="fc"><i>837</i>&nbsp;        }</b>
<i>838</i>&nbsp;
<i>839</i>&nbsp;        @Override
<i>840</i>&nbsp;        protected Analyzer getWrappedAnalyzer(String fieldName) {
<b class="nc"><i>841</i>&nbsp;            MappedFieldType fieldType = fullName(fieldName);</b>
<b class="nc"><i>842</i>&nbsp;            if (fieldType != null) {</b>
<b class="nc"><i>843</i>&nbsp;                Analyzer analyzer = extractAnalyzer.apply(fieldType);</b>
<b class="nc"><i>844</i>&nbsp;                if (analyzer != null) {</b>
<b class="nc"><i>845</i>&nbsp;                    return analyzer;</b>
<i>846</i>&nbsp;                }
<i>847</i>&nbsp;            }
<b class="nc"><i>848</i>&nbsp;            return defaultAnalyzer;</b>
<i>849</i>&nbsp;        }
<i>850</i>&nbsp;    }
<i>851</i>&nbsp;
<i>852</i>&nbsp;    public synchronized List&lt;String&gt; reloadSearchAnalyzers(AnalysisRegistry registry) throws IOException {
<b class="nc"><i>853</i>&nbsp;        logger.info(&quot;reloading search analyzers&quot;);</b>
<i>854</i>&nbsp;        // refresh indexAnalyzers and search analyzers
<b class="nc"><i>855</i>&nbsp;        final Map&lt;String, TokenizerFactory&gt; tokenizerFactories = registry.buildTokenizerFactories(indexSettings);</b>
<b class="nc"><i>856</i>&nbsp;        final Map&lt;String, CharFilterFactory&gt; charFilterFactories = registry.buildCharFilterFactories(indexSettings);</b>
<b class="nc"><i>857</i>&nbsp;        final Map&lt;String, TokenFilterFactory&gt; tokenFilterFactories = registry.buildTokenFilterFactories(indexSettings);</b>
<b class="nc"><i>858</i>&nbsp;        final Map&lt;String, Settings&gt; settings = indexSettings.getSettings().getGroups(&quot;index.analysis.analyzer&quot;);</b>
<b class="nc"><i>859</i>&nbsp;        final List&lt;String&gt; reloadedAnalyzers = new ArrayList&lt;&gt;();</b>
<b class="nc"><i>860</i>&nbsp;        for (NamedAnalyzer namedAnalyzer : indexAnalyzers.getAnalyzers().values()) {</b>
<b class="nc"><i>861</i>&nbsp;            if (namedAnalyzer.analyzer() instanceof ReloadableCustomAnalyzer) {</b>
<b class="nc"><i>862</i>&nbsp;                ReloadableCustomAnalyzer analyzer = (ReloadableCustomAnalyzer) namedAnalyzer.analyzer();</b>
<b class="nc"><i>863</i>&nbsp;                String analyzerName = namedAnalyzer.name();</b>
<b class="nc"><i>864</i>&nbsp;                Settings analyzerSettings = settings.get(analyzerName);</b>
<b class="nc"><i>865</i>&nbsp;                analyzer.reload(analyzerName, analyzerSettings, tokenizerFactories, charFilterFactories, tokenFilterFactories);</b>
<b class="nc"><i>866</i>&nbsp;                reloadedAnalyzers.add(analyzerName);</b>
<i>867</i>&nbsp;            }
<b class="nc"><i>868</i>&nbsp;        }</b>
<b class="nc"><i>869</i>&nbsp;        return reloadedAnalyzers;</b>
<i>870</i>&nbsp;    }
<i>871</i>&nbsp;}
</div>
</div>

<div class="footer">
    
    <div style="float:right;">generated on 2020-02-09 18:46</div>
</div>
</body>
</html>
